-- Script was generated by Devart dbForge Studio for MySQL, Version 5.0.50.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 2015/12/2 15:45:41
-- Server version: 5.6.25-log
-- Client version: 4.1

-- 
-- Disable foreign keys
-- 
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

-- 
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8';

DELIMITER $$

--
-- Definition for view v_currmenu
--
DROP VIEW IF EXISTS v_currmenu CASCADE $$
CREATE OR REPLACE SQL SECURITY INVOKER

VIEW v_currmenu
AS
	select tm.menuid AS menuid from ((t_branch_info tbf join t_menu_branch mb) join t_menu tm) where ((tbf.branchid = mb.branchid) and (mb.menuid = tm.menuid) and (tm.status = '1')) order by tm.effecttime desc limit 1 $$

--
-- Definition for view v_order
--
DROP VIEW IF EXISTS v_order CASCADE $$
CREATE OR REPLACE SQL SECURITY INVOKER
VIEW v_order
AS
	select a.tableNo AS tableNo,a.tableid AS tableid,a.orderid AS orderid,c.dishid AS dishid,c.title AS title,b.dishunit AS dishunit,b.dishnum AS dishnum,b.orderprice AS orderprice,b.orderdetailid AS orderdetailid,b.orderseq AS orderseq from ((t_table a join t_order_detail b) join t_dish c) where ((a.orderid = b.orderid) and (b.dishid = c.dishid)) $$

--
-- Definition for view v_revenuepayway
--
DROP VIEW IF EXISTS v_revenuepayway CASCADE $$
CREATE OR REPLACE SQL SECURITY INVOKER
VIEW v_revenuepayway
AS
SELECT t_dictionary.dictid AS dictid
     , t_dictionary.itemid AS itemid
     , t_dictionary.itemDesc AS itemDesc
     , t_dictionary.itemSort AS itemSort
     , t_dictionary.status AS status
     , t_dictionary.type AS type
     , t_dictionary.typename AS typename
     , t_dictionary.begin_time AS begin_time
     , t_dictionary.end_time AS end_time
     , t_dictionary.charges_status AS charges_status
     , t_dictionary.member_price AS member_price
     , t_dictionary.price AS price
     , t_dictionary.date_type AS date_type
     , t_dictionary.item_value AS item_value
FROM
  t_dictionary
WHERE
  ((t_dictionary.itemid IN ('0', '1', '5', '8', '13', '17', '18'))
  AND (t_dictionary.type = 'PAYWAY')) $$

--
-- Definition for view v_t_p_preferential_activity
--
DROP VIEW IF EXISTS v_t_p_preferential_activity CASCADE $$
CREATE OR REPLACE SQL SECURITY INVOKER
VIEW v_t_p_preferential_activity
AS
	select (case when (a.preferential = a.id) then b.name else ifnull(ifnull(a.free_reason,a.company_name),b.name) end) AS id,(case when (a.preferential = a.id) then b.name else ifnull(ifnull(a.free_reason,a.company_name),b.name) end) AS name,b.type AS type,b.type_name AS type_name,b.sub_type AS sub_type,b.sub_type_name AS sub_type_name,a.preferential AS preferential from (t_p_preferential_detail a join t_p_preferential_activity b on((a.preferential = b.id))) union select distinct t_settlement_detail.bankcardno AS id,t_settlement_detail.bankcardno AS name,'12' AS type,'会员' AS type_name,'' AS sub_type,'' AS sub_type_name,t_settlement_detail.bankcardno AS preferential from t_settlement_detail where (t_settlement_detail.payway = '12')$$




DROP PROCEDURE IF EXISTS p_cal_dishset_price$$
CREATE PROCEDURE p_cal_dishset_price()
SQL SECURITY INVOKER
COMMENT '计算套餐的实收金额'
BEGIN
  DECLARE v_fetch_done           NUMERIC DEFAULT 0;
  DECLARE v_primarykey           VARCHAR(50);
  DECLARE v_dishset_debitamount  DECIMAL(10, 2);
  DECLARE v_dishset_orignalprice DECIMAL(10, 2);

  DECLARE cur_dish_set CURSOR FOR
  SELECT *
  FROM
    t_temp_dishset tod;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_fetch_done = 1;


  #如果套餐没有使用优惠，则将套餐的价格设置成订单价格
  UPDATE t_temp_order_detail
  SET
    debitamount = dishnum * orderprice
  WHERE
    dishtype = '2'
    AND primarykey = superkey
    AND debitamount IS NULL;

  #找出所有套餐的外壳
  DROP TEMPORARY TABLE IF EXISTS t_temp_dishset;
  CREATE TEMPORARY TABLE t_temp_dishset
  (
    primarykey VARCHAR(50),
    debitamount DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dishset
  SELECT primarykey
       , debitamount
  FROM
    t_temp_order_detail tod
  WHERE
    dishtype = '2'
    AND primarykey = superkey;

  OPEN cur_dish_set;

loop_lable:
  LOOP
    FETCH cur_dish_set INTO v_primarykey, v_dishset_debitamount;

    #获取套餐总的原价
    SELECT sum(ifnull(dishnum * orignalprice, 0))
    INTO
      v_dishset_orignalprice
    FROM
      t_temp_order_detail
    WHERE
      superkey = v_primarykey
      AND primarykey != v_primarykey;

    #循环结束标识
    IF v_fetch_done THEN
      LEAVE loop_lable;
    END IF;

    UPDATE t_temp_order_detail
    SET
      debitamount = dishnum * orignalprice / v_dishset_orignalprice * v_dishset_debitamount
    WHERE
      superkey = v_primarykey
      AND primarykey != v_primarykey;
  END LOOP;
  CLOSE cur_dish_set;
END
$$

DROP PROCEDURE IF EXISTS p_cal_dish_column$$
CREATE PROCEDURE p_cal_dish_column(IN i_cloumnId  VARCHAR(800),
                                   IN i_flag      INT(2),
                                   IN i_dz_amount DECIMAL(10, 2)
                                   )
SQL SECURITY INVOKER
COMMENT '处理dish 分类的实收字段'
BEGIN
  DECLARE v_sum_dishprice DECIMAL(10, 2);

  ### 不管是分类类型，还是“除分类”类型的优惠，都需要先根据传入的cloumnId找出的对应的记录
  ### 下面的程序，知道判定i_flag的值前，都是在做这件事件。并把结果集保存在t_temp_dish表中                         


  #这个临时表用来存储鱼锅的primarykey
  DROP TEMPORARY TABLE IF EXISTS t_temp_primarykey;
  CREATE TEMPORARY TABLE t_temp_primarykey
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #找出所有应用到优惠的鱼锅primarykey
  INSERT INTO t_temp_primarykey
  SELECT a.primarykey
  FROM
    t_temp_order_detail a, t_dish_dishtype b
  WHERE
    a.dishid = b.dishid
    AND find_in_set(b.columnid, i_cloumnId)
    AND a.orderprice IS NULL
    AND a.dishtype = '1';

  DROP TEMPORARY TABLE IF EXISTS t_temp_dish_hotpot;
  CREATE TEMPORARY TABLE t_temp_dish_hotpot
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  #找出所以应用到优惠的鱼锅明细
  INSERT INTO t_temp_dish_hotpot
  SELECT a.primarykey
       , a.dishnum * a.orderprice
       , a.debitamount
  FROM
    t_temp_order_detail a, t_temp_primarykey b
  WHERE
    a.parentkey = b.primarykey;


  #这个临时表用来存储使用优惠的菜品
  DROP TEMPORARY TABLE IF EXISTS t_temp_dish;
  CREATE TEMPORARY TABLE t_temp_dish
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dish
  #找出所有的普通菜品和套餐
  SELECT a.primarykey
       , a.dishnum * a.orderprice
       , a.debitamount
  FROM
    t_temp_order_detail a, t_dish_dishtype b
  WHERE
    a.dishid = b.dishid
    AND find_in_set(b.columnid, i_cloumnId)
    AND orderprice > 0
  UNION
  SELECT primarykey
       , orderprice
       , debitprice
  FROM
    t_temp_dish_hotpot;


  #分类优惠
  IF i_flag = 0 THEN

    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitprice IS NOT NULL THEN
             debitprice
           ELSE
             orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_dish;

    #计算实收价格
    UPDATE t_temp_order_detail a, t_temp_dish b
    SET
      a.debitamount =
      CASE
      WHEN a.debitamount IS NOT NULL THEN
        a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
      ELSE
        a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
      END
    WHERE
      a.primarykey = b.primarykey;


  #针对“除某一分类”的优惠
  ELSE
    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitamount IS NOT NULL THEN
             debitamount
           ELSE
             dishnum * orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_order_detail
    WHERE
      orderprice > 0
      AND primarykey NOT IN (SELECT primarykey
                             FROM
                               t_temp_dish);


    #计算实收价格
    UPDATE t_temp_order_detail a
    SET
      a.debitamount =
      CASE
      WHEN a.debitamount IS NOT NULL THEN
        a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
      ELSE
        a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
      END
    WHERE
      orderprice > 0
      AND primarykey NOT IN (SELECT primarykey
                             FROM
                               t_temp_dish);
  END IF;


END
$$

DROP PROCEDURE IF EXISTS p_cal_dish_debit_amount$$
CREATE PROCEDURE p_cal_dish_debit_amount(IN  i_orderid VARCHAR(255),
                                         OUT o_message VARCHAR(255),
                                         OUT o_flag    INT
                                         )
SQL SECURITY INVOKER
COMMENT '计算单品的实收金额'
label_main:
BEGIN DECLARE v_fetch_done     NUMERIC DEFAULT 0;
  DECLARE v_coupondetailid VARCHAR(100);
  DECLARE v_caltype        INT(2);
  DECLARE v_dishtype       INT(2);
  DECLARE v_dishnum        INT(11);
  DECLARE v_dishid         VARCHAR(5000);
  DECLARE v_columnid       VARCHAR(5000);
  DECLARE v_orderdetailid  VARCHAR(100);
  DECLARE v_primarykey     VARCHAR(100);

  DECLARE v_sdetailid      VARCHAR(50);
  DECLARE v_payamount      DECIMAL(10, 2);
  DECLARE v_payway         INT(2);
  DECLARE v_couponNum      INT(3);
  DECLARE v_ys_amount      DECIMAL(10, 2);
  DECLARE v_bankcardno     VARCHAR(100);
  DECLARE v_coupon_count   INT;
  DECLARE v_xz_amount      DECIMAL(10, 2);

  DECLARE cur_order CURSOR FOR
  SELECT t.sdetailid
       , t.payamount
       , t.bankcardno
       , t.payway
       , t.couponNum
       , t.coupondetailid
       , CASE
         WHEN caltype IS NULL THEN
           99
         ELSE
           caltype
         END caltype
       , b.dishtype
       , b.dishid
       , b.columnid
  FROM
    t_temp_settlement_detail t
  LEFT JOIN t_dish_cal_factor_temp b
  ON
  t.coupondetailid = b.coupondetailid
  ORDER BY
    caltype;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_fetch_done = 1;

  #创建订单详情临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishid VARCHAR(50),
    dishtype CHAR(1),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    orderprice DOUBLE(13, 2),
    debitamount DOUBLE(13, 2),
    pricetype CHAR(1),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    parentkey VARCHAR(50),
    dishunit VARCHAR(50),
    ismaster VARCHAR(3),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_order_detail
  SELECT orderid
       , dishid
       , dishtype
       , dishnum
       , orignalprice
       , orderprice
       , NULL
       , pricetype
       , childdishtype
       , primarykey
       , parentkey
       , dishunit
       , ismaster
       , superkey
  FROM
    t_order_detail t
  WHERE
    t.orderid = i_orderid;

  #创建结算明细临时内存表 
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail(
    sdetailid VARCHAR(50),
    orderid VARCHAR(50),
    payamount DECIMAL(10, 2),
    bankcardno VARCHAR(100),
    payway INT(2),
    couponNum INT(3),
    coupondetailid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_settlement_detail
  SELECT sdetailid
       , orderid
       , payamount
       , bankcardno
       , payway
       , couponNum
       , coupondetailid
  FROM
    t_settlement_detail tsd
  WHERE
    tsd.orderid = i_orderid
    AND tsd.payway IN ('6', '7', '12');

  #循环遍历使用的优惠券,计算每一张优惠券的减免金额
  OPEN cur_order;

loop_label:
  LOOP

    FETCH cur_order INTO v_sdetailid, v_payamount, v_bankcardno, v_payway, v_couponNum, v_coupondetailid, v_caltype, v_dishtype, v_dishid, v_columnid;

    #循环结束标识
    IF v_fetch_done THEN
      LEAVE loop_label;
    END IF;



    #0 单品 1 双拼锅 2 除单品 3 分类 4 除分类 5 整单
    #针对某一单品的优惠
    IF v_caltype = '0' THEN
      CALL p_cal_dish_single(v_dishid, '0', v_payamount);
    #针对双拼锅优免20做特殊处理
    ELSEIF v_caltype = '1' THEN
      CALL p_cal_double_hotpot(v_payamount);
    #针对“除某一单品”的优惠
    ELSEIF v_caltype = '2' THEN
      CALL p_cal_dish_single(v_dishid, '1', v_payamount);
    #针对某一分类的优惠
    ELSEIF v_caltype = '3' THEN
      CALL p_cal_dish_column(v_columnid, '0', v_payamount);
    #针对“除某一分类”的优惠
    ELSEIF v_caltype = '4' THEN
      CALL p_cal_dish_column(v_columnid, '1', v_payamount);
    #整单优免
    ELSEIF v_caltype = '5' THEN
      CALL p_cal_whole_order(v_payamount);
    #抹零的情况没有coupondetailid
    ELSE
      CALL p_cal_whole_order(v_payamount);
    END IF;
  END LOOP;
  CLOSE cur_order;

  #把虚增按菜价均摊到每个菜上
  SELECT ifnull(sum(Inflated), 0)
  INTO
    v_xz_amount
  FROM
    t_order_member
  WHERE
    orderid = i_orderId;

  IF v_xz_amount > 0 THEN
    CALL p_cal_whole_order(v_xz_amount);
  END IF;

  #最后集中对套餐处理一下
  -- CALL p_xxxxxxxx
  CALL p_cal_dishset_price();

  #没有使用到优惠的菜品，实收就是订单价格
  UPDATE t_temp_order_detail
  SET
    debitamount = orderprice * dishnum
  WHERE
    debitamount IS NULL;

  #将中间表中的结果更新到正式表中
  UPDATE t_order_detail a, t_temp_order_detail b
  SET
    a.debitamount = b.debitamount
  WHERE
    a.primarykey = b.primarykey;

END
$$

DROP PROCEDURE IF EXISTS p_cal_dish_single$$
CREATE PROCEDURE p_cal_dish_single(IN i_dishid    VARCHAR(800),
                                   IN i_flag      INT(2),
                                   IN i_dz_amount DECIMAL(10, 2)
                                   )
SQL SECURITY INVOKER
COMMENT '处理单品的实收字段'
BEGIN
  DECLARE v_sum_dishprice DECIMAL(10, 2);

  ### 不管是单品类型，还是“除单品”类型的优惠，都需要先根据传入的dishid找出的对应的记录
  ### 下面的程序，知道判定i_flag的值前，都是在做这件事件。并把结果集保存在t_temp_dish表中                         

  #这个临时表用来存储鱼锅的primarykey
  DROP TEMPORARY TABLE IF EXISTS t_temp_primarykey;
  CREATE TEMPORARY TABLE t_temp_primarykey
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #找出所有应用到优惠的鱼锅primarykey
  INSERT INTO t_temp_primarykey
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    find_in_set(dishid, i_dishid)
    AND orderprice IS NULL
    AND dishtype = '1';

  DROP TEMPORARY TABLE IF EXISTS t_temp_dish_hotpot;
  CREATE TEMPORARY TABLE t_temp_dish_hotpot
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  #找出所以应用到优惠的鱼锅明细
  INSERT INTO t_temp_dish_hotpot
  SELECT a.primarykey
       , a.dishnum * a.orderprice
       , a.debitamount
  FROM
    t_temp_order_detail a, t_temp_primarykey b
  WHERE
    a.parentkey = b.primarykey;


  #这个临时表用来存储使用优惠的菜品
  DROP TEMPORARY TABLE IF EXISTS t_temp_dish;
  CREATE TEMPORARY TABLE t_temp_dish
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dish
  #找出所有的普通菜品和套餐
  SELECT primarykey
       , dishnum * orderprice
       , debitamount
  FROM
    t_temp_order_detail
  WHERE
    find_in_set(dishid, i_dishid)
    AND orderprice > 0
  UNION
  SELECT primarykey
       , orderprice
       , debitprice
  FROM
    t_temp_dish_hotpot;

  #单品优惠
  IF i_flag = 0 THEN

    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitprice IS NOT NULL THEN
             debitprice
           ELSE
             orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_dish;

    #计算实收价格
    UPDATE t_temp_order_detail a, t_temp_dish b
    SET
      a.debitamount =
      CASE
      WHEN a.debitamount IS NOT NULL THEN
        a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
      ELSE
        a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
      END
    WHERE
      a.primarykey = b.primarykey;


  #针对“除某一单品”的优惠
  ELSE
    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitamount IS NOT NULL THEN
             debitamount
           ELSE
             dishnum * orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_order_detail
    WHERE
      orderprice > 0
      AND primarykey NOT IN (SELECT primarykey
                             FROM
                               t_temp_dish);


    #计算实收价格
    UPDATE t_temp_order_detail a
    SET
      a.debitamount =
      CASE
      WHEN a.debitamount IS NOT NULL THEN
        a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
      ELSE
        a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
      END
    WHERE
      orderprice > 0
      AND primarykey NOT IN (SELECT primarykey
                             FROM
                               t_temp_dish);
  END IF;
END
$$

DROP PROCEDURE IF EXISTS p_cal_double_hotpot$$
CREATE PROCEDURE p_cal_double_hotpot(IN i_dz_amount DECIMAL(10, 2))
SQL SECURITY INVOKER
COMMENT '处理整单优惠的情况'
BEGIN

  DECLARE v_sum_dishprice     DECIMAL(10, 2);
  DECLARE v_double_hotpot_key VARCHAR(50) DEFAULT NULL;

  #找出双拼锅
  SELECT parentkey
  INTO
    v_double_hotpot_key
  FROM
    t_temp_order_detail
  WHERE
    dishtype = 1
    AND orderprice > 0
  GROUP BY
    parentkey
  HAVING
    count(1) = 4
  LIMIT
    1;

  #将双拼锅优惠均摊到2个锅底和2个鱼上
  IF v_double_hotpot_key IS NOT NULL THEN
    UPDATE t_temp_order_detail
    SET
      debitamount =
      CASE
      WHEN debitamount IS NOT NULL THEN
        debitamount - i_dz_amount / 4
      ELSE
        orderprice * dishnum - i_dz_amount / 4
      END
    WHERE
      parentkey = v_double_hotpot_key;
  END IF;

END
$$

DROP PROCEDURE IF EXISTS p_cal_whole_order$$
CREATE PROCEDURE p_cal_whole_order(IN i_dz_amount DECIMAL(10, 2))
SQL SECURITY INVOKER
COMMENT '处理整单优惠的情况'
BEGIN

  DECLARE v_sum_dishprice DECIMAL(10, 2);

  #计算总价格
  SELECT sum(
         CASE
         WHEN debitamount IS NOT NULL THEN
           debitamount
         ELSE
           dishnum * orderprice
         END)
  INTO
    v_sum_dishprice
  FROM
    t_temp_order_detail
  WHERE
    orderprice > 0;

  #计算每个菜品的实收价格
  UPDATE t_temp_order_detail
  SET
    debitamount =
    CASE
    WHEN debitamount IS NOT NULL THEN
      debitamount - (debitamount / v_sum_dishprice) * i_dz_amount
    ELSE
      orderprice * dishnum - (dishnum * orderprice / v_sum_dishprice) * i_dz_amount
    END
  WHERE
    orderprice > 0;
END
$$



--
-- Definition for procedure p_calcDishPrice
--
DROP PROCEDURE IF EXISTS p_calcDishPrice$$
CREATE PROCEDURE p_calcDishPrice(IN i_orderId varchar(255))
  SQL SECURITY INVOKER
BEGIN


  DECLARE v_message varchar(255);
  DECLARE v_flag int;

  CALL newspicyway.p_cal_dish_debit_amount(i_orderId, v_message, v_flag);

END
$$

--
-- Definition for procedure p_calcDishSetPrice
--
DROP PROCEDURE IF EXISTS p_calcDishSetPrice$$
CREATE PROCEDURE p_calcDishSetPrice(IN i_orderId varchar(255))
  SQL SECURITY INVOKER
BEGIN
      DECLARE v_message varchar(255);
  DECLARE v_flag int;

  CALL newspicyway.p_cal_dish_debit_amount(i_orderId, v_message, v_flag);
END
$$

--
-- Definition for procedure p_caletableamount
--
DROP PROCEDURE IF EXISTS p_caletableamount$$
CREATE PROCEDURE p_caletableamount(IN v_orderid varchar(50))
  SQL SECURITY INVOKER
BEGIN
  DECLARE v_couponname varchar(100);
  DECLARE v_fulldiscountrate decimal(10,2);
  declare v_dueamount  decimal(10,2);
  declare v_ssamount decimal(10,2);
  declare v_gzamount decimal(10,2);
  declare v_ymamount decimal(10,2);
  select a.fulldiscountrate,couponname INTO  v_fulldiscountrate,v_couponname from t_order a    where orderid=v_orderid;
  
  set v_fulldiscountrate = 1;
  update t_order_detail set discountrate=1 where orderid=v_orderid;
  
  
  
  update t_order_detail set payamount=0, discountamount=0,predisamount=0  where ((status<>5 and  (not (orderprice>0))) or (status=5))  and orderid=v_orderid;
  update t_order_detail set payamount=orderprice*dishnum*(case when discountrate<=0 then 1 else discountrate end), discountamount=orderprice*dishnum*(1-case when discountrate<=0 then 1 else discountrate end),predisamount=orderprice*dishnum  where    status<>5 and  orderprice>0  and orderid=v_orderid;
  select IFNULL(sum(payamount),0) into v_dueamount from t_order_detail where   status<>5 and  orderid=v_orderid ;
  select IFNULL(sum(payamount),0) into v_ssamount from t_settlement_detail where orderid=v_orderid and payway in(0,1,8,11,17,18);
  select IFNULL(sum(payamount),0) into v_gzamount from t_settlement_detail where orderid=v_orderid and payway in(5,13);
  select IFNULL(sum(payamount),0) into v_ymamount from t_settlement_detail where orderid=v_orderid and payway in(6,12);
  update t_order set dueamount=v_dueamount,wipeamount=v_dueamount-floor(v_dueamount),ssamount=v_ssamount,gzamount=v_gzamount,ymamount=v_ymamount where orderid=v_orderid;
END
$$

--
-- Definition for procedure p_cal_dishset_price
--
DROP PROCEDURE IF EXISTS p_cal_dishset_price$$
CREATE PROCEDURE p_cal_dishset_price()
  SQL SECURITY INVOKER
  COMMENT '计算套餐的实收金额'
BEGIN
  DECLARE v_fetch_done           NUMERIC DEFAULT 0;
  DECLARE v_primarykey           VARCHAR(50);
  DECLARE v_dishset_debitamount  DECIMAL(10, 2);
  DECLARE v_dishset_orignalprice DECIMAL(10, 2);

  DECLARE cur_dish_set CURSOR FOR
  SELECT *
  FROM
    t_temp_dishset tod;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_fetch_done = 1;


  
  UPDATE t_temp_order_detail
  SET
    debitamount = dishnum * orderprice
  WHERE
    dishtype = '2'
    AND primarykey = superkey
    AND debitamount IS NULL;

  
  DROP TEMPORARY TABLE IF EXISTS t_temp_dishset;
  CREATE TEMPORARY TABLE t_temp_dishset
  (
    primarykey VARCHAR(50),
    debitamount DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dishset
  SELECT primarykey
       , debitamount
  FROM
    t_temp_order_detail tod
  WHERE
    dishtype = '2'
    AND primarykey = superkey;

  OPEN cur_dish_set;

loop_lable:
  LOOP
    FETCH cur_dish_set INTO v_primarykey, v_dishset_debitamount;

    
    SELECT sum(ifnull(dishnum * orignalprice, 0))
    INTO
      v_dishset_orignalprice
    FROM
      t_temp_order_detail
    WHERE
      superkey = v_primarykey
      AND primarykey != v_primarykey;

    
    IF v_fetch_done THEN
      LEAVE loop_lable;
    END IF;

    UPDATE t_temp_order_detail
    SET
      debitamount = dishnum * orignalprice / v_dishset_orignalprice * v_dishset_debitamount
    WHERE
      superkey = v_primarykey
      AND primarykey != v_primarykey;
  END LOOP;
  CLOSE cur_dish_set;
END
$$




--
-- Definition for procedure p_endwork
--
DROP PROCEDURE IF EXISTS p_endwork$$
CREATE PROCEDURE p_endwork(OUT v_endfinish BIT)
SQL SECURITY INVOKER
BEGIN
  DECLARE t_error    INTEGER DEFAULT 0;
  DECLARE v_branchid VARCHAR(50);
  DECLARE v_tenantid VARCHAR(50);
  DECLARE v_now      DATETIME;
  DECLARE v_opendate DATETIME;
  DECLARE v_username VARCHAR(20);

  -- 异常处理模块，出现异常回滚(20151204 shangwenchao added)
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
  	set t_error = 1;
  	set v_endfinish = false;
    ROLLBACK;
  END;


  # 初始化数据 (20151204 shangwenchao added)
  SET v_now = now();
  # 分店id 和 租户id
  SELECT branchid
       , tenantid
  INTO
    v_branchid, v_tenantid
  FROM
    t_branch_info
  LIMIT
    1;

  # 开业日期 和 用户
  SELECT opendate
       , username
  INTO
    v_opendate, v_username
  FROM
    t_open_log
  LIMIT
    1;



  START TRANSACTION;

  INSERT INTO t_biz_log (id, branchid, tenantid, syn_status, inserttime, open_date, end_date, open_user) VALUES (uuid(), v_branchid, v_tenantid, 1, v_now, v_opendate, v_now, v_username);

  DELETE
  FROM
    t_branch_biz_log;

  INSERT INTO t_branch_biz_log (id, opendate, enddate, openuser, enduser, inserttime, branchid) VALUES (uuid(), v_opendate, v_now, v_username, NULL, v_now, v_branchid);

  DELETE
  FROM
    t_open_log;

  DELETE
  FROM
    t_operation_log;

  DELETE
  FROM
    t_json_record;

  UPDATE tableseqno
  SET
    val = 2
  WHERE
    name IN ('printobjid', 'printdishid');

  DELETE
  FROM
    t_printobj;

  DELETE
  FROM
    t_printdish;

  UPDATE t_printer
  SET
    printnum = 0;

  UPDATE t_table
  SET
    orderid = '';

  UPDATE t_b_user
  SET
    order_num = NULL, lastlogintime = NULL;

  UPDATE sequence
  SET
    val = 1
  WHERE
    name = 'one';

  INSERT INTO t_syn_sql_history
  SELECT *
  FROM
    t_syn_sql;

  DELETE
  FROM
    t_syn_sql;

  # 20151204 shangwenchao added
  # 情空消息推送信息
  DELETE
  FROM
    t_syncclient;
  DELETE
  FROM
    t_syncmsg;



  IF t_error = 1 THEN
    SET v_endfinish = FALSE;
    ROLLBACK;
  ELSE
    SET v_endfinish = TRUE;
    COMMIT;
  END IF;

END
$$

--
-- Definition for procedure p_mergetable
--
DROP PROCEDURE IF EXISTS p_mergetable$$
CREATE PROCEDURE p_mergetable(IN i_targettableno varchar(50), IN i_orignaltableno varchar(50), INOUT o_result varchar(50))
  SQL SECURITY INVOKER
BEGIN

  DECLARE v_count int;
  DECLARE v_r_status varchar(2);
  DECLARE v_r_order varchar(100);
  DECLARE v_target_order_id varchar(100);
  DECLARE v_d_orderid varchar(100);
  DECLARE v_status varchar(2);
  DECLARE v_orderid varchar(100);
  DECLARE v_tableid varchar(100);
  declare v_man_num  int;
  declare v_woman_num  int;
  declare v_person_num int;
  declare v_child_num int;
  declare v_ageperiod  varchar(100);
  declare v_t_man_num  int;
  declare v_t_woman_num  int;
  declare v_t_person_num int;
  declare v_t_ageperiod  varchar(100);
  declare v_t_child_num int;

  DECLARE v_t_tableid varchar(100);
  DECLARE v_t_tableid_t varchar(100);
  DECLARE v_t_status varchar(2);
  DECLARE v_t_orderid varchar(100);
  DECLARE v_orderstatus int;
  DECLARE v_t_orderstatus int;
  DECLARE v_relateorderid varchar(3000);
  DECLARE v_t_relateorderid varchar(300);
  declare v_memberno  varchar(50);
  declare v_t_memberno  varchar(50);
  declare v_menuid  varchar(100);

  
   
SELECT
    COUNT(1) INTO v_count
  FROM t_table
  WHERE tableno = i_orignaltableno;

 
   select menuid into v_menuid   from v_currmenu;

  
 
IF v_count = 1 THEN
    
 
SELECT
      COUNT(1) INTO v_count
    FROM t_table
    WHERE tableno = i_targettableno;
 

    
 
IF v_count = 1 THEN

      
      delete  from t_operation_log where tableno = i_orignaltableno;
     delete  from t_operation_log where tableno = i_targettableno;
     
SELECT
        status,
        orderid,
        tableid INTO v_status, v_orderid, v_tableid
      FROM t_table
      WHERE tableno = i_orignaltableno;
 

      

    
SELECT
        status,
        orderid,
        tableid INTO v_t_status, v_t_orderid, v_t_tableid_t
      FROM t_table
      WHERE tableno = i_targettableno;
 
 
if v_orderid = v_t_orderid then
         
SET o_result = '0';
 
      else
             
     
IF v_orderid IS NOT NULL THEN
           
        
SELECT
          t.relateorderid,
          orderstatus,custnum,womanNum,childNum,mannum,ageperiod,memberno
       INTO v_relateorderid, v_orderstatus,v_person_num,v_woman_num,v_child_num,v_man_num,v_ageperiod,v_memberno
        FROM t_order t
        WHERE t.orderid = v_orderid;
 
        
    
IF v_orderstatus != 3 AND v_orderstatus != 2 THEN
          
         
IF v_t_orderid IS NOT NULL THEN

       
         
SELECT
              t.relateorderid,
              orderstatus ,custnum,womanNum,childNum,mannum,ageperiod,memberno
            INTO v_t_relateorderid, v_t_orderstatus,v_t_person_num,v_t_woman_num,
                 v_t_child_num,v_t_man_num,v_t_ageperiod,v_t_memberno
            FROM t_order t
            WHERE t.orderid = v_t_orderid;
 
IF v_t_orderstatus != 3  and v_t_orderstatus != 2  THEN

             
       if v_memberno is null and v_t_memberno is not null then
          
           update t_order set memberno = v_t_memberno 
           where orderid = v_orderid;

          call newspicyway.p_update2vipprice(v_orderid);
 
       else 
           if v_memberno is not null  and v_t_memberno is null then
             
             update t_order set memberno = v_memberno 
             where orderid = v_t_orderid;

            call newspicyway.p_update2vipprice(v_t_orderid);

           end if;
       end if; 
 
IF v_t_relateorderid IS NULL
                OR v_t_relateorderid = '' THEN

   
          
        UPDATE t_order_detail
													SET orderid = v_orderid
													WHERE orderid = v_t_orderid;


           update t_printdish set printobjid = (select id from t_printobj where orderno =v_orderid)
           where printobjid = (select id from t_printobj where orderno = v_t_orderid);
					 
													
												 
					UPDATE t_order_detail_discard
													SET orderid = v_orderid
													WHERE orderid = v_t_orderid;
 


											
										 
			UPDATE t_table
											SET orderid = v_orderid,status ='1'
											WHERE tableid = v_t_tableid_t;
			 

											
											
			UPDATE t_order
											SET payway = '1',
													relateorderid = CONCAT(v_tableid, ',', v_t_tableid_t),
													custnum = custnum + ifnull(v_t_person_num,0),
													womanNum = womanNum + ifnull(v_t_woman_num,0),
													 childNum = childNum + ifnull(v_t_child_num,0),
													mannum = mannum + ifnull(v_t_man_num,0),
													ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
													memberno = ifNUll(v_memberno,v_t_memberno)
											WHERE orderid = v_orderid;

    
 
					 
IF v_t_orderid!=v_orderid AND v_t_orderid IS NOT NULL THEN
                
				DELETE
													FROM t_order
												WHERE orderid = v_t_orderid;
				 
											END IF;

 ELSE

                
         
			UPDATE t_table
											SET orderid = v_orderid
											WHERE orderid = v_t_orderid;
 

                
             
UPDATE t_order_detail
                SET orderid = v_orderid
                WHERE orderid = v_t_orderid;
 

                
   
UPDATE t_order_detail_discard
                SET orderid = v_orderid
                WHERE orderid = v_t_orderid;

           update t_printdish set printobjid = (select id from t_printobj where orderno =v_orderid)
           where printobjid = (select id from t_printobj where orderno = v_t_orderid);
 

                

              
UPDATE t_order
                SET relateorderid = CONCAT(IFNULL(v_relateorderid, v_tableid), ',', v_t_relateorderid),
                    custnum = custnum + ifnull(v_t_person_num,0),
                    womanNum = womanNum + ifnull(v_t_woman_num,0),
                     childNum = childNum + ifnull(v_t_child_num,0),
                    mannum = mannum + ifnull(v_t_man_num,0),
                    ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
                    memberno = ifNUll(v_memberno,v_t_memberno)
                WHERE orderid = v_orderid;
 

                
							 
IF v_t_orderid!=v_orderid AND v_t_orderid IS NOT NULL THEN
            
                  DELETE
                  FROM t_order
                WHERE orderid = v_t_orderid;
 
								END IF;
              END IF;
ELSE
              
 
            
        UPDATE t_table
              SET status = '1',orderid = v_orderid
              WHERE tableid = v_t_tableid_t;
 

              
              
        UPDATE t_order
              SET payway = '1',
                  relateorderid = CONCAT(v_tableid, ',', v_t_tableid_t),
                    custnum = custnum + ifnull(v_t_person_num,0),
                    womanNum = womanNum + ifnull(v_t_woman_num,0),
                     childNum = childNum + ifnull(v_t_child_num,0),
                    mannum = mannum + ifnull(v_t_man_num,0),
                    ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
                    memberno = ifNUll(v_memberno,v_t_memberno)
              WHERE orderid = v_orderid;
 

            END IF;
          ELSE
            
        
         UPDATE t_table
												SET status = '1',
														orderid = v_orderid
												WHERE tableid = v_t_tableid_t;
						 

												
												 
						UPDATE t_order
												SET payway = '1',
														relateorderid = CONCAT(v_tableid, ',', v_t_tableid_t),
																custnum = custnum + ifnull(v_t_person_num,0),
																womanNum = womanNum + ifnull(v_t_woman_num,0),
																 childNum = childNum + ifnull(v_t_child_num,0),
																mannum = mannum + ifnull(v_t_man_num,0),
																ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
																memberno = ifNUll(v_memberno,v_t_memberno)
												WHERE orderid = v_orderid;
 

          END IF;

        END IF;

      END IF;

      end if;

   
     
SET o_result = '0';
 
    ELSE
     
SET o_result = '1';
 
    END IF;
  ELSE
     
SET o_result = '1';
 
  END IF;

 
END
$$

--
-- Definition for procedure p_orderdish
--
DROP PROCEDURE IF EXISTS p_orderdish$$
CREATE PROCEDURE p_orderdish(IN i_orderid varchar(50), IN i_printobjid int, INOUT o_result varchar(50))
  SQL SECURITY INVOKER
BEGIN
  

  DECLARE flag int;

  

  DECLARE v_g_printobjid int;

  DECLARE v_r_status varchar(2);

  DECLARE V_TABLEID varchar(100);

  DECLARE v_order varchar(100);

  DECLARE v_printobj_count int;

  DECLARE v_printdish_count int;

  DECLARE v_tablearea varchar(100) CHARACTER SET utf8;

  DECLARE v_orderid varchar(50);

  DECLARE v_tableno varchar(100) CHARACTER SET utf8;

  DECLARE v_dishid varchar(50);

  DECLARE v_dishstatus varchar(50);

  DECLARE v_begintime datetime;

  DECLARE v_endtime datetime;

  DECLARE v_sperequire varchar(200) CHARACTER SET utf8;

  DECLARE v_dishnum varchar(50);

  DECLARE v_userName varchar(100) CHARACTER SET utf8;

  DECLARE v_orderprice decimal(10, 2);

  DECLARE v_discountrate decimal(10, 2);

  DECLARE v_discountamount decimal(10, 2);

  DECLARE v_fishcode varchar(50);

  DECLARE v_dishtype int(11);

  DECLARE v_status int(11);

  DECLARE v_dishunit varchar(50) CHARACTER SET utf8;

  DECLARE v_payamount decimal(10, 2);

  DECLARE v_predisamount decimal(10, 2);

  DECLARE v_couponid varchar(50);

  DECLARE v_disuserid varchar(50);

  DECLARE v_orignalprice decimal(10, 2);

  DECLARE v_pricetype varchar(10);

  DECLARE v_printtype varchar(10);

  DECLARE v_printdishid int;

  DECLARE v_open_date date;

  DECLARE v_open_date_str varchar(50);

  DECLARE v_maxDishCount int;

  DECLARE v_printaddress varchar(100);

  DECLARE v_printport varchar(10);

  DECLARE v_timemsg varchar(30);

  DECLARE v_customeraddress varchar(100);

  DECLARE v_customerport varchar(10);

  DECLARE v_relatedishid varchar(4000);

  DECLARE v_orderseq integer;

  DECLARE v_dishname varchar(300) CHARACTER SET utf8;

  DECLARE v_full_name varchar(30) CHARACTER SET utf8;

  DECLARE done int DEFAULT 0;

  DECLARE tmpFlag int;

  DECLARE v_printer varchar(100);

  DECLARE v_ordertype  int;  

  DECLARE v_parentkey varchar(255); 

  DECLARE v_superkey varchar(255);

  DECLARE v_ismaster int ;

  DECLARE v_primarykey varchar(255); 

  DECLARE v_islatecooke  int ; 

  DECLARE v_isadddish  int;  

  DECLARE v_childdishtype int; 

  DECLARE v_ispot  int ; 

  DECLARE v_dish_count int;
   DECLARE v_menu_dish_count int;

  DECLARE v_branch_id varchar(50);

  declare v_order_detail_count int;

declare v_menuid  varchar(50);

    DECLARE autocommit int;

   DECLARE cur_order CURSOR FOR

  SELECT

    orderid,

    dishid,

    dishstatus,

    begintime,

    endtime,

    sperequire,

    dishnum,

    userName,

    orderprice,

    discountrate,

    discountamount,

    fishcode,

    dishtype,

    status,

    dishunit,

    payamount,

    predisamount,

    couponid,

    userName,

    orignalprice,

    pricetype,

    printtype,

    relatedishid,

    
   ordertype,
   parentkey,
   superkey,
   ismaster,
    primarykey,
    islatecooke,
    isadddish ,
    childdishtype,
    ispot 

  FROM t_order_detail_temp t
  WHERE t.orderid =  i_orderid for update;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    select count(1) into v_order_detail_count from t_order_detail where orderid = i_orderid;
     if v_order_detail_count = 0 THEN
        set v_orderseq = 1;
     ELSE
         select max(orderseq) + 1 into v_orderseq from t_order_detail where orderid = i_orderid;
     end if ;


  OPEN cur_order;

  REPEAT

    FETCH cur_order INTO v_orderid,

    v_dishid,

    v_dishstatus,

    v_begintime,

    v_endtime,

    v_sperequire,

    v_dishnum,

    v_userName,

    v_orderprice,

    v_discountrate,

    v_discountamount,

    v_fishcode,

    v_dishtype,

    v_status,

    v_dishunit,

    v_payamount,

    v_predisamount,

    v_couponid,

    v_disuserid,

    v_orignalprice,

    v_pricetype,

    v_printtype,

    v_relatedishid,

 
   v_ordertype,
   v_parentkey,
   v_superkey,
   v_ismaster,
   v_primarykey,
   v_islatecooke,
   v_isadddish ,
   v_childdishtype,
   v_ispot;
        
  IF done <> 1 THEN

      IF v_open_date IS NULL THEN

        SELECT

          tol.opendate INTO v_open_date

        FROM t_open_log tol;

      END IF;



      IF v_open_date_str IS NULL THEN

        SELECT

          SUBSTRING(i_orderid, 1, 9) INTO v_open_date_str;

      END IF;
 

     
   
 
    INSERT INTO  t_order_detail (orderdetailid,orderid, dishid, dishstatus, begintime, endtime, sperequire, dishnum,
        userName, orderprice, discountrate, discountamount, fishcode,
        dishtype, status, dishunit, payamount, predisamount,
        couponid, disuserid, orignalprice,
        pricetype, orderseq,relatedishid,   
        ordertype,
        parentkey,
        superkey,
        ismaster,
        primarykey,
        islatecooke,
        isadddish ,
        childdishtype,
        ispot)

          VALUES (uuid(),v_orderid, v_dishid, v_dishstatus, v_begintime, v_endtime, v_sperequire, v_dishnum, v_userName, v_orderprice, v_discountrate, v_discountamount, v_fishcode, v_dishtype, v_status, v_dishunit, v_payamount, v_predisamount, v_couponid, v_disuserid, v_orignalprice, v_pricetype, v_orderseq,v_relatedishid,
             v_ordertype,
             v_parentkey,
             v_superkey,
             v_ismaster,
             v_primarykey,
             v_printtype,
             v_isadddish ,
             v_childdishtype,
             v_ispot
          );
 

  
  SELECT  tableseqno('printdishid') INTO v_printdishid;
   
   SELECT COUNT(1) INTO v_dish_count 
    FROM t_dish td
      WHERE dishid = v_dishid; 

   IF v_dish_count > 0 then

		select tm.menuid into v_menuid
    from t_branch_info tbf,
        t_menu_branch mb,
        t_menu tm 
		where tbf.branchid = mb.branchid 
		 and mb.menuid = tm.menuid
		 and tm.status ='1' order by tm.effecttime desc limit 1;

		SELECT COUNT(1) INTO v_menu_dish_count
      FROM t_template_dishunit
		 where menuid = v_menuid 
						and dishid = v_dishid;
    IF v_menu_dish_count>0 THEN

		select IFNULL(dishname,'') into v_dishname 
		 from t_template_dishunit
		 where menuid = v_menuid 
						and dishid = v_dishid limit 1;

    
    

    else 
       SELECT
        td.title INTO v_dishname
      FROM t_dish td
      WHERE dishid = v_dishid;
      END IF;
    end IF;
  
   

      SELECT      CURRENTTABLEID INTO V_TABLEID
      FROM t_order T
      WHERE T.orderid = v_orderid;


   
      SELECT
        CONCAT('桌号:', ' ', IFNULL(tableno, '')) INTO v_tableno
      FROM t_tablearea ta,
           t_table tb
      WHERE tb.areaid = ta.areaid
      AND tb.tableid = V_TABLEID;

   
     IF v_dishtype IS not NULL AND  v_dishtype = '1'   AND v_parentkey != v_primarykey THEN
        set v_dishname  = CONCAT('-',v_dishname);

      END IF;
    
    IF v_dishtype IS not NULL AND   v_dishtype = '2'  AND v_parentkey != v_primarykey THEN
        set v_dishname  = CONCAT('-',v_dishname);
    END IF;

    
     INSERT INTO  t_printdish (printdishid
        , printobjid
        , dishname
        , dishnum
        , dishprice
        , totalamount
        , payamount
        , sperequire
        , tableNomsg
        , dishUnit
        , printipaddress
        , printport
        , printnum
        , dishid
       , printtype
        , relatedishid
        , orderseq
        , dishtype
        , printerId,
          ordertype,
          parentkey,
          superkey,
          ismaster,
          primarykey,
          islatecooke,
          isadddish ,
          childdishtype,
          ispot )

          VALUES (v_printdishid 
          , i_printobjid 
          , v_dishname 
          , v_dishnum 
          , v_orderprice 
          , 0 
          , 0 
          ,  v_sperequire  
          , v_tableno 
          , v_dishunit 
          , v_printaddress 
          , v_printport 
          , '0', v_dishid, IFNULL(v_printtype, 2), v_relatedishid, v_orderseq, v_dishtype, v_printer,
           v_ordertype,
           v_parentkey,
           v_superkey,
           v_ismaster,
           v_primarykey,
           v_printtype,
           v_isadddish ,
           v_childdishtype,
          v_ispot  
          );
   

    set v_dishname = NULL;
    set v_printtype = null;
    END IF;

  UNTIL done = 1
  END REPEAT;

  CLOSE cur_order;

  
  SELECT
    COUNT(1) INTO v_printobj_count
  FROM t_printobj tp

  WHERE tp.orderno = i_orderid;

  

  IF v_printobj_count = 0 THEN

    SELECT     CURRENTTABLEID INTO V_TABLEID
    FROM t_order T
    WHERE T.orderid = v_orderid;

    UPDATE t_table
    SET status = '1',orderid = v_orderid
    WHERE tableid = V_TABLEID;

    UPDATE t_order
    SET orderstatus = '0'
    WHERE orderid = v_orderid;
 
    SELECT   CURRENT_TIMESTAMP() INTO v_timemsg;



   select branchid into v_branch_id from t_branch_info limit 1;

   select name INTO v_full_name from t_b_user where id
     in (select user_id  from t_b_employee where job_number = v_userName and branch_id = v_branch_id);


    SELECT CURRENTTABLEID INTO V_TABLEID
    FROM t_order T
    WHERE T.orderid = v_orderid;

    SELECT    ta.areaname INTO v_tablearea
    FROM t_tablearea ta,   t_table tb
    WHERE tb.areaid = ta.areaid
    AND tb.tableid = V_TABLEID;


  

    INSERT INTO t_printobj (id,
    printtype
    , orderno
    , username
    , tableno
    , timemsg
    , customerprinterip
    , customerprinterport
    , tablearea,
     tableid)

      VALUES (i_printobjid,
      '3', 
      i_orderid,
      v_full_name,
      v_tableno,
      v_timemsg, 
      v_customeraddress, 
      v_customerport,
      v_tablearea,
      V_TABLEID
      );

  END IF;


 
   DELETE

     FROM t_order_detail_temp

   WHERE orderid = i_orderid;
 


  SET o_result = i_printobjid;

END
$$

--
-- Definition for procedure p_setOrderDish
--
DROP PROCEDURE IF EXISTS p_setOrderDish$$
CREATE PROCEDURE p_setOrderDish(IN i_orderid varchar(50), INOUT o_result varchar(50))
  SQL SECURITY INVOKER
BEGIN


  DECLARE v_printobjid int;

  DECLARE v_printobj_count int;
 

SELECT

    COUNT(1) INTO v_printobj_count

  FROM t_printobj tp

  WHERE tp.orderno = i_orderid;
 

IF v_printobj_count = 0 THEN
 

SELECT

      tableseqno('printobjid') INTO v_printobjid;
 

  ELSE
 

SELECT DISTINCT

      tp.id INTO v_printobjid

    FROM t_printobj tp

    WHERE tp.orderno = i_orderid;
 

  END IF;

CALL newspicyway.p_orderdish(i_orderid, v_printobjid, o_result);
 

END
$$

--
-- Definition for procedure p_setordermember
--
DROP PROCEDURE IF EXISTS p_setordermember$$
CREATE PROCEDURE p_setordermember(IN v_orderid varchar(50), IN v_pricetype int)
  SQL SECURITY INVOKER
BEGIN
  DECLARE done numeric;
  DECLARE v_dishid varchar(50);
  DECLARE v_orderdetailid int;
  DECLARE v_dishunit varchar(50);
  DECLARE v_template_vipprice decimal(10, 2);
  declare v_menuid varchar(100);
  DECLARE cur_orderlist CURSOR FOR
  select a.dishid,a.orderdetailid,a.dishunit from t_order_detail a inner join t_dish b on(a.dishid=b.dishid) where a.orderprice>0 and a.orderid=v_orderid;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  select menuid into v_menuid from v_currmenu;
  OPEN cur_orderlist;
  REPEAT
    FETCH cur_orderlist INTO v_dishid, v_orderdetailid,v_dishunit;
    IF done <> 1 THEN
      if(v_pricetype=0)then
        select vipprice INTO v_template_vipprice from t_template_dishunit where (menuid =v_menuid or(dishid='DISHES_98')) and dishid=v_dishid and (unit=v_dishunit or (dishid='DISHES_98')) LIMIT 1;
       else
        select price INTO v_template_vipprice from t_template_dishunit where (menuid =v_menuid or(dishid='DISHES_98')) and dishid=v_dishid and (unit=v_dishunit or (dishid='DISHES_98')) LIMIT 1;
      END IF;
      if(v_template_vipprice>0)THEN
        update t_order_detail set orderprice=v_template_vipprice where orderid=v_orderid and orderdetailid=v_orderdetailid;
      end if;
   END IF;
  UNTIL done = 1
  END REPEAT;
  CLOSE cur_orderlist;
  CALL newspicyway.p_caletableamount(v_orderid);
END
$$


--
-- Definition for procedure p_start_cloud_menu
--
DROP PROCEDURE IF EXISTS p_start_cloud_menu$$
CREATE PROCEDURE p_start_cloud_menu()
  SQL SECURITY INVOKER
BEGIN

  UPDATE t_menu tm SET tm.status='1' WHERE tm.status='2' AND tm.effecttime<=NOW();
END
$$

--
-- Definition for procedure p_switch
--
DROP PROCEDURE IF EXISTS p_switch$$
CREATE PROCEDURE p_switch(IN i_targettableno varchar(50), IN i_orignaltableno varchar(50), INOUT o_result varchar(50))
  SQL SECURITY INVOKER
BEGIN
  DECLARE v_count int;
  DECLARE v_status varchar(2);
  DECLARE v_orderid varchar(100);
  DECLARE v_t_orderid varchar(100);
  DECLARE v_table_orginal_id varchar(100);

  DECLARE v_tableid varchar(100);
  DECLARE v_orderstatus varchar(2);
  DECLARE v_t_orderstatus varchar(2);

  DECLARE v_tableno  varchar(300);

  SELECT
    COUNT(1) INTO v_count
  FROM t_table
  WHERE tableno = i_orignaltableno;
  IF v_count = 1 THEN
    SELECT
      COUNT(1) INTO v_count
    FROM t_table
    WHERE tableno = i_targettableno
    AND status = '0';
    IF v_count = 1 THEN
      SELECT
        status,
        orderid,
        tableid INTO v_status, v_orderid, v_table_orginal_id
      FROM t_table
      WHERE tableno = i_orignaltableno;

      SELECT
        tableid,
        orderid INTO v_tableid, v_t_orderid
      FROM t_table
      WHERE tableno = i_targettableno;

      IF v_status = 0 THEN
        SET v_status = 1;
      END IF;

     
     update t_operation_log 
     set tableno = i_targettableno
     where tableno in ( 
                  select tableno  from t_table where orderid in (
                   select orderid  from t_table 
                      where tableno = i_orignaltableno) );

      
      UPDATE t_table
      SET orderid = NULL,
          status = 0
      WHERE orderid = v_orderid;



      
      UPDATE t_table
      SET orderid = v_orderid,
          status = v_status
      WHERE tableNo = i_targettableno;

      UPDATE t_order
      SET currenttableid = v_tableid,
          relateorderid = NULL,
          payway = NULL
      WHERE orderid = v_orderid;


     SELECT
        CONCAT('桌号:', ' ', IFNULL(tableno, '')) INTO v_tableno
      FROM t_tablearea ta,
           t_table tb
      WHERE tb.areaid = ta.areaid
      AND tb.tableid = v_tableid;

        
     UPDATE t_printobj tp
      SET tp.tableno = v_tableno,
          tp.tableid = v_tableid
      where tp.orderno =   v_orderid ;


      delete  from t_operation_log where tableno = i_orignaltableno;
     delete  from t_operation_log where tableno = i_targettableno;

    
      SET o_result = '0';
    ELSE
      SET o_result = '1';
    END IF;
  ELSE
    SET o_result = '1';
  END IF;


END
$$

--
-- Definition for procedure p_syndata
--
DROP PROCEDURE IF EXISTS p_syndata$$
CREATE PROCEDURE p_syndata(IN i_branch_id varchar(50), INOUT i_result varchar(10))
  SQL SECURITY INVOKER
BEGIN
  
  DECLARE done int DEFAULT 0;
  DECLARE v_id varchar(50);
  DECLARE v_branchid varchar(50);
  DECLARE v_sqltext longtext;
  DECLARE v_inserttime datetime;
  DECLARE v_status int;
  DECLARE v_generatetime datetime;
  DECLARE v_insert_str varchar(50);
  DECLARE v_orderSeqno integer;

  DECLARE cur_order CURSOR FOR

  SELECT
    id,
    branchid,
    sqltext,
    inserttime,
    status,
    generattime,
    orderSeqno
  FROM t_syn_sql t
  WHERE t.status = '0' AND (sqltext != NULL OR sqltext != '')
  ORDER BY orderseqno, generattime
  ;
  


  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  OPEN cur_order;

  REPEAT

    FETCH cur_order INTO v_id, v_branchid, v_sqltext, v_inserttime, v_status, v_generatetime, v_orderSeqno;

    IF done <> 1 THEN

      SET v_insert_str = UPPER(SUBSTRING(TRIM(v_sqltext), 1, 6));
      IF v_insert_str = 'INSERT' THEN
        SET v_sqltext = CONCAT('INSERT IGNORE ', SUBSTRING(TRIM(v_sqltext), 7));
      END IF;
      SET @sqlstr = v_sqltext;
      PREPARE v_sql FROM @sqlstr;
      EXECUTE v_sql;
      DEALLOCATE PREPARE v_sql;

    END IF;


  UNTIL done = 1
  END REPEAT;

  CLOSE cur_order;

  UPDATE t_syn_sql
  SET STATUS = '1'; 

  SET i_result = '1';

END
$$

--
-- Definition for procedure p_update2vipprice
--
DROP PROCEDURE IF EXISTS p_update2vipprice$$
CREATE PROCEDURE p_update2vipprice(IN i_orderid varchar(50))
  SQL SECURITY INVOKER
BEGIN
 
 
 DECLARE done int DEFAULT 0;
 DECLARE v_orderprice decimal;
 DECLARE v_orignalprice decimal;
 DECLARE v_vipprice  decimal;
 DECLARE v_dishid  varchar(50);
 DECLARE v_dishunit varchar(50);

 declare v_menuid  varchar(50);
 

DECLARE cur_order CURSOR FOR

  SELECT t.orderprice,t.orignalprice,t.dishid,t.dishunit
    FROM t_order_detail t
  WHERE t.orderid =  i_orderid AND dishid !='DISHES_98' AND orderprice > 0;

 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
 
OPEN cur_order;

 
REPEAT

     
IF done <> 1 THEN

      
select menuid into v_menuid   from v_currmenu;
 
select DISTINCT vipprice INTO   v_vipprice from t_template_dishunit 
        where menuid  = v_menuid and unit =v_dishunit  and dishid = v_dishid;
 
UPDATE t_order_detail 
        set orderprice = v_vipprice
      WHERE dishid = v_dishid AND dishunit = v_dishunit
      AND  ORDERid = i_orderid;
 
       
   END IF;

  UNTIL done = 1
  END REPEAT;

 
CLOSE cur_order;

 
END
$$

--
-- Definition for function fristPinyin
--
DROP FUNCTION IF EXISTS fristPinyin$$
CREATE FUNCTION fristPinyin(P_NAME VARCHAR(255))
  RETURNS varchar(255) CHARSET utf8
  SQL SECURITY INVOKER
BEGIN

    DECLARE V_RETURN VARCHAR(255);

    SET V_RETURN = ELT(INTERVAL(CONV(HEX(left(CONVERT(P_NAME USING gbk),1)),16,10), 

        0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7, 

        0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,

        0xC8F6,0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),    

    'A','B','C','D','E','F','G','H','J','K','L','M','N','O','P','Q','R','S','T','W','X','Y','Z');

    RETURN V_RETURN;

END
$$

--
-- Definition for function f_cal_dish_count
--
DROP FUNCTION IF EXISTS f_cal_dish_count$$
CREATE FUNCTION f_cal_dish_count(i_coupondetailid varchar(100), i_orderid varchar(50))
  RETURNS int(11)
  SQL SECURITY INVOKER
BEGIN
  DECLARE v_count int;
  SELECT
    COUNT(1) INTO v_count
  FROM t_order_detail tod
  WHERE tod.orderid = i_orderid
  AND tod.debitamount != NULL
  AND tod.debitamount > 0
  AND FIND_IN_SET(tod.dishid, (SELECT
      dishid
    FROM t_dish_cal_factor_temp tdcft
    WHERE tdcft.coupondetailid = i_coupondetailid));

  RETURN v_count;
END
$$

--
-- Definition for function getPY
--
DROP FUNCTION IF EXISTS getPY$$
CREATE FUNCTION getPY(in_string VARCHAR(1000))
  RETURNS text CHARSET utf8
  SQL SECURITY INVOKER
BEGIN

DECLARE tmp_str VARCHAR(1000) charset utf8 DEFAULT '' ; 

DECLARE tmp_len SMALLINT DEFAULT 0;

DECLARE tmp_char VARCHAR(2) charset gbk DEFAULT '';

DECLARE tmp_rs VARCHAR(1000) charset gbk DEFAULT '';

DECLARE tmp_cc VARCHAR(2) charset gbk DEFAULT '';

SET tmp_str = in_string;

SET tmp_len = LENGTH(tmp_str);

WHILE tmp_len > 0 DO 

SET tmp_char = LEFT(tmp_str,1);

SET tmp_cc = tmp_char;

IF LENGTH(tmp_char)>1 THEN

SELECT ELT(INTERVAL(CONV(HEX(tmp_char),16,10),0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,0xBFA6,0xC0AC 

,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,0xCBFA,0xCDDA ,0xCEF4,0xD1B9,0xD4D1), 

'A','B','C','D','E','F','G','H','J','K','L','M','N','O','P','Q','R','S','T','W','X','Y','Z') INTO tmp_cc; 

END IF; 

SET tmp_rs = CONCAT(tmp_rs,tmp_cc);

SET tmp_str = SUBSTRING(tmp_str,2);

SET tmp_len = LENGTH(tmp_str);

END WHILE; 

RETURN tmp_rs;

END
$$

--
-- Definition for function getseqno
--
DROP FUNCTION IF EXISTS getseqno$$
CREATE FUNCTION getseqno(seq_name varchar(20))
  RETURNS varchar(100) CHARSET utf8
  SQL SECURITY INVOKER
BEGIN

  DECLARE valuestr varchar(200);

  DECLARE maxvalues int;

  DECLARE v_branchid varchar(10);

  DECLARE v_current_date varchar(20);

  DECLARE v_max_order_id varchar(30);

  DECLARE v_order_id_suffix varchar(10);

  DECLARE v_order_id_seq varchar(30);

  DECLARE v_count_order int;


  
  SET v_current_date = DATE_FORMAT(NOW(), '%Y%m%d');
  SELECT
    LPAD(branchid, 6, '0') INTO v_branchid
  FROM t_branch_info;

  SELECT
    COUNT(1) INTO v_count_order
  FROM t_order
  WHERE orderid LIKE '%' || CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid) || '%';

  IF v_count_order > 0 THEN
    SELECT
      MAX(orderid) INTO v_max_order_id
    FROM t_order
    WHERE orderid LIKE '%' || CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid) || '%';

    SELECT
      RIGHT(v_max_order_id, 6) INTO v_max_order_id
    FROM dual;
    SELECT
      v_max_order_id + 1 INTO v_order_id_seq
    FROM dual;
    UPDATE sequence
    SET val = CAST(v_order_id_seq AS SIGNED)
    WHERE name = seq_name;
    SET valuestr = CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid, LPAD(v_order_id_seq, 6, '0'));
  ELSE

    SELECT
      MAX(val) INTO maxvalues
    FROM sequence
    WHERE name = seq_name;
    SELECT
      LPAD(maxvalues + 1, 6, '0') INTO valuestr;
    UPDATE sequence
    SET val = maxvalues + 1
    WHERE name = seq_name;
    SET valuestr = CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid, valuestr);
  END IF;

  RETURN valuestr;

END
$$

--
-- Definition for function tableseqno
--
DROP FUNCTION IF EXISTS tableseqno$$
CREATE FUNCTION tableseqno(seq_name char (20))
  RETURNS int(11)
  SQL SECURITY INVOKER
begin 

 UPDATE tableseqno SET val=last_insert_id(val+1) WHERE name=seq_name; 

 RETURN last_insert_id(); 

end
$$

--
-- Definition for event event1
--
DROP EVENT IF EXISTS event1$$
CREATE 
EVENT event1
	ON SCHEDULE EVERY '3' MINUTE
	STARTS '2015-08-04 17:53:28'
	ON COMPLETION PRESERVE
	DO 
BEGIN
  declare branchcount int; 
  declare v_branchid int;
  declare v_menuid int;
  select count(1) into branchcount from t_branch_info;
  if branchcount>0 then
    select branchid into v_branchid from t_branch_info;
    update t_menu tm SET tm.status='1' WHERE tm.status='2' AND tm.effecttime<=NOW() and tm.menuid IN (SELECT tmb.menuid FROM t_menu_branch tmb WHERE tmb.branchid=v_branchid);
    select menuid into v_menuid from v_currmenu;
    update t_menu set status='4' where status='1' and menuid!=v_menuid and menuid IN (SELECT tmb.menuid FROM t_menu_branch tmb WHERE tmb.branchid=v_branchid);
  else
    UPDATE t_menu tm SET tm.status='1' WHERE tm.status='2' AND tm.effecttime<=NOW();
    end if;
END
$$

DROP PROCEDURE IF EXISTS p_report_jsfsmxb$$
CREATE PROCEDURE p_report_jsfsmxb(IN  pi_branchid INT(11), -- 分店id
                                  IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                  IN  pi_ksrq     DATETIME, -- 开始日期，
                                  IN  pi_jsrq     DATETIME, -- 结束日期
                                  OUT po_errmsg   VARCHAR(100)
                                  )
SQL SECURITY INVOKER
COMMENT '结算方式明细表'
label_main:
BEGIN
  -- 返回字段说明如下(3个字段)：
  -- 结算方式 笔数 金额
  --
  -- 返回数据举例（返回值包含多条数据）：
  -- 现金	11	4467.00
  -- 优免	1	14.50
  -- 抹零	1	0.50

  DECLARE v_date_start DATETIME;
  DECLARE v_date_end   DATETIME;

  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;

  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;

  #处理开始结束时间
  SET v_date_start = pi_ksrq;
  SET v_date_end = pi_jsrq;

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;

  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);

  #创建结算明细内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail
  (
    orderid VARCHAR(50),
    payway INT,
    payamount DOUBLE(13, 2),
    membercardno varchar(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生产临时结算明细表数据
  INSERT INTO t_temp_settlement_detail
  SELECT b.orderid
       , b.payway
       , b.payamount
       , case when b.membercardno='1' then '1' else '0' end  -- 1 工行 0 它行
  FROM
    t_temp_order a, t_settlement_detail b
  WHERE
    a.orderid = b.orderid
    AND b.payamount > 0
    AND b.payway IN (0, 1, 5, 8, 11, 12, 13, 17, 18);  -- shangwenchao 2015/12/21 22:46:49 增加结算方式13


  #创建结果内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    payway VARCHAR(50),
    nums INT,
    prices DOUBLE(13, 2),
    membercardno VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_res
  SELECT payway
       , count(1)
       , ifnull(sum(payamount), 0)
       , membercardno
  FROM
    t_temp_settlement_detail
  GROUP BY
    payway,membercardno;

  --   #对payway=13的归入到优免里
  --   UPDATE t_temp_res
  --   SET
  --     payway = '6'
  --   WHERE
  --     payway = '13';


  #返回结果集
  SELECT b.itemDesc AS payway
       , b.itemid
       , a.nums
       , a.prices
       , membercardno
  FROM
    t_temp_res a, t_dictionary b
  WHERE
    a.payway = b.itemid
    AND b.type = 'PAYWAY'
  ORDER BY
    b.itemSort;

#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
END
$$

DROP PROCEDURE IF EXISTS p_report_pxxsmxb$$
CREATE PROCEDURE p_report_pxxsmxb(IN  pi_branchid INT(11), -- 分店id
                                  IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                  IN  pi_ksrq     DATETIME, -- 开始日期，
                                  IN  pi_jsrq     DATETIME, -- 结束日期
                                  IN  pi_pl       VARCHAR(50), -- 品类 -1:全部  非-1:品类ID
                                  IN  pi_lx       VARCHAR(10), -- 品项类型  -1:全部  0:单品 1:鱼锅 2:套餐
                                  OUT po_errmsg   VARCHAR(100)
                                  -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '品项销售明细表'
label_main:
BEGIN


  # 返回字段说明如下(6个字段)：
  # 品类id 品类	品项类型编号 品项类型	数量	份额(%)
  #
  # 返回数据举例（返回值包含多条数据）：
  # 12356466 凉菜	0 单品	4	4.65


  DECLARE v_count       INT;
  DECLARE v_sum         INT;
  DECLARE v_total_count DOUBLE(13, 2);
  DECLARE v_item_desc   VARCHAR(50); #菜品分类名称
  DECLARE v_item_id     VARCHAR(50); #菜品分类id
  DECLARE v_date_start  DATETIME;
  DECLARE v_date_end    DATETIME;

  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;


  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  SET @@max_heap_table_size = 1024 * 1024 * 400;
  SET @@tmp_table_size = 1024 * 1024 * 400;

  #处理开始结束时间
  SET v_date_start = pi_ksrq; # str_to_date(concat(date_format(pi_ksrq, '%Y-%m-%d'), '00:00:00'), '%Y-%m-%d %H:%i:%s');
  SET v_date_end = pi_jsrq; # str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');

  -- 创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    PRIMARY KEY (orderid)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;

  -- 创建订单详情临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(40),
    dishnum DOUBLE(13, 2),
    dishid VARCHAR(40),
    dishtype INT,
    ispot TINYINT,
    parentkey VARCHAR(40),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  -- 向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT a.orderid
       , a.dishnum
       , a.dishid
       , a.dishtype
       , a.ispot
       , a.parentkey
       , a.childdishtype
       , a.primarykey
       , a.superkey
  FROM
    t_temp_order b, t_order_detail a
  WHERE
    b.orderid = a.orderid
    AND a.orignalprice > 0;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;

  CREATE INDEX ix_t_temp_order_detail_dishid ON t_temp_order_detail (dishid);

  ########################################## begin: 如果后来单下的鱼，需要将此类的品项统计成单品#################################
  DROP TEMPORARY TABLE IF EXISTS t_temp_parentkey;
  CREATE TEMPORARY TABLE t_temp_parentkey
  (
    parentkey VARCHAR(40)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #记录所有后来单加的鱼的key值
  INSERT INTO t_temp_parentkey
  SELECT DISTINCT parentkey
  FROM
    t_temp_order_detail
  WHERE
    ispot = 1
    AND dishnum = 0;

  #删除无用个锅底
  DELETE
  FROM
    t_temp_order_detail
  WHERE
    ispot = 1
    AND dishnum = 0;

  #更新单加的鱼为单品
  UPDATE t_temp_order_detail a, t_temp_parentkey b
  SET
    a.dishtype = 0
  WHERE
    a.parentkey = b.parentkey;

  ########################################## end: 如果后来单下的鱼，需要将此类的品项统计成单品#################################


  # 更新订单详情表中的菜品类别
  UPDATE t_temp_order_detail a, t_dish b
  SET
    a.dishtype = b.dishtype
  WHERE
    a.dishid = b.dishid
    AND a.dishtype IS NULL;

  -- 计算总的售卖份数
  -- 注意的地方：1\一个菜属于多个分类，这该菜的售卖份数只计算一次；
  SELECT ifnull(sum(dishnum), 0)
  INTO
    v_total_count
  FROM
    t_temp_order_detail;

  IF v_total_count <= 0 THEN
    SELECT NULL;
    SET po_errmsg = '数据为空，无查询结果';
    LEAVE label_main;
  END IF;


  # 创建结果内存表
  -- 品类	品项类型	数量	份额(%)
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    id VARCHAR(50),
    itemDesc VARCHAR(50),
    dishtype INT,
    dishtypetitle VARCHAR(50),
    number DOUBLE(13, 2),
    share DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;


  INSERT INTO t_temp_res (id, dishType, number)
  SELECT b.columnid
       , a.dishtype
       , ifnull(sum(a.dishnum), 0)
  FROM
    t_temp_order_detail a, t_dish_dishtype b
  WHERE
    a.dishid = b.dishid
  GROUP BY
    b.columnid
  , a.dishtype
  ORDER BY
    NULL;


  -- 更新菜品类型
  UPDATE t_temp_res
  SET
    dishtypetitle =
    CASE dishType
    WHEN 0 THEN
      '单品'
    WHEN 1 THEN
      '鱼锅'
    ELSE
      '套餐'
    END;


  -- 更新菜品分类
  UPDATE t_temp_res t, t_basicdata a
  SET
    t.itemDesc = a.itemDesc
  WHERE
    t.Id = a.id
    AND a.status = 1;

  -- 更新比例
  UPDATE t_temp_res
  SET
    share = number / v_total_count * 100;


  #需要计算餐具数据的场景（全部，或者 只查询餐具）
  IF pi_pl = -1 OR pi_pl = 'DISHES_98' THEN
    SELECT ifnull(sum(dishnum), 0)
    INTO
      v_sum
    FROM
      t_temp_order_detail
    WHERE
      dishid = 'DISHES_98';

    IF v_sum > 0 THEN
      INSERT INTO t_temp_res VALUES ('DISHES_98', '餐具', 0, '单品', v_sum, v_sum / v_total_count * 100);
    END IF;
  END IF;
  COMMIT;

  #返回结果集
  IF pi_pl = -1 AND pi_lx = -1 THEN
    SELECT *
    FROM
      t_temp_res;
  ELSEIF pi_pl != -1 AND pi_lx = -1 THEN
    SELECT *
    FROM
      t_temp_res
    WHERE
      Id = pi_pl;
  ELSEIF pi_pl = -1 AND pi_lx != -1 THEN
    SELECT *
    FROM
      t_temp_res
    WHERE
      dishtype = pi_lx;
  ELSE
    SELECT *
    FROM
      t_temp_res
    WHERE
      Id = pi_pl
      AND dishtype = pi_lx;
  END IF;

#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_parentkey;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
END
$$

DROP PROCEDURE IF EXISTS p_report_pxxsmxb_zhixiang$$
CREATE PROCEDURE p_report_pxxsmxb_zhixiang(IN  pi_branchid INT(11), -- 分店id
                                           IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                           IN  pi_ksrq     DATETIME, -- 开始日期，
                                           IN  pi_jsrq     DATETIME, -- 结束日期
                                           IN  pi_pl       VARCHAR(50), -- 品类ID, -1 代表全部
                                           IN  pi_pxlx     INT, -- 品项类型 -1 代表全部
                                           OUT po_errmsg   VARCHAR(100)
                                           -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '品项销售明细表'
label_main:
BEGIN -- 返回字段说明如下(6个字段)：
  -- 品项名称	品项编号	单价	单位	数量	份额(%)
  --
  -- 返回数据举例（返回值包含多条数据）：
  -- 白汤梭边鱼	20405	55	斤	7	8.14

  DECLARE v_total_count DOUBLE(13, 2) DEFAULT 0;
  DECLARE v_title       VARCHAR(50); #菜品名称
  DECLARE v_dishNo      VARCHAR(50); #品项编号
  DECLARE v_price       DOUBLE(13, 2); #单价
  DECLARE v_unit        VARCHAR(50); #单位
  DECLARE v_number      DOUBLE(13, 2); #数量
  DECLARE v_share       DOUBLE(13, 2); #占比
  DECLARE v_fetch_done  INT DEFAULT FALSE;
  DECLARE v_dishid      VARCHAR(50);
  DECLARE v_dishclass   VARCHAR(50);
  DECLARE v_dishtype    INT;
  DECLARE v_date_start  DATETIME;
  DECLARE v_date_end    DATETIME;
  DECLARE cur_dish_detail CURSOR FOR SELECT a.dishid
                                          , a.dishunit
                                          , a.dishtype
                                          , b.columnid
                                          , ifnull(sum(a.dishnum), 0)
                                          , ifnull(max(a.orignalprice), 0)
                                     FROM
                                       t_temp_order_detail a, t_dish_dishtype b
                                     WHERE
                                       a.dishid = b.dishid
                                     GROUP BY
                                       a.dishid
                                     , a.dishunit
                                     , a.dishtype
                                     , b.columnid
                                     ORDER BY
                                       NULL;

  DECLARE CONTINUE HANDLER FOR NOT FOUND
  BEGIN
    SET v_fetch_done = TRUE; #当读到数据的最后一条时,设置v_fetch_done变量为TRUE
  END;


  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;

  #判断参数
  IF pi_sb IS NULL OR pi_ksrq IS NULL OR pi_jsrq IS NULL OR pi_pl IS NULL OR pi_pxlx IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '传入参数不能为空';
    LEAVE label_main;
  END IF;

  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  SET @@max_heap_table_size = 1024 * 1024 * 400;
  SET @@tmp_table_size = 1024 * 1024 * 400;

  #处理开始结束时间
  SET v_date_start = pi_ksrq; #str_to_date(concat(date_format(pi_ksrq, '%Y-%m-%d'), '00:00:00'), '%Y-%m-%d %H:%i:%s');
  SET v_date_end = pi_jsrq; #str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');

  -- 创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    PRIMARY KEY (orderid)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;

  -- 创建订单详情临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(40),
    dishnum DOUBLE(13, 2),
    dishid VARCHAR(40),
    dishtype INT,
    dishunit VARCHAR(10),
    orignalprice DOUBLE(13, 2),
    ispot TINYINT,
    parentkey VARCHAR(40),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  -- 向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT a.orderid
       , a.dishnum
       , a.dishid
       , a.dishtype
       , a.dishunit
       , a.orignalprice
       , a.ispot
       , a.parentkey
       , a.childdishtype
       , a.primarykey
       , a.superkey
  FROM
    t_temp_order b, t_order_detail a
  WHERE
    b.orderid = a.orderid
    AND a.orignalprice > 0;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;
  CREATE INDEX ix_t_tmp_order_detail_dishid ON t_temp_order_detail (dishid);

  ########################################## begin: 如果后来单下的鱼，需要将此类的品项统计成单品#################################
  DROP TEMPORARY TABLE IF EXISTS t_temp_parentkey;
  CREATE TEMPORARY TABLE t_temp_parentkey
  (
    parentkey VARCHAR(40)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #记录所有后来单加的鱼的key值
  INSERT INTO t_temp_parentkey
  SELECT DISTINCT parentkey
  FROM
    t_temp_order_detail
  WHERE
    ispot = 1
    AND dishnum = 0;

  #删除无用个锅底
  DELETE
  FROM
    t_temp_order_detail
  WHERE
    ispot = 1
    AND dishnum = 0;

  #更新单加的鱼为单品
  UPDATE t_temp_order_detail a, t_temp_parentkey b
  SET
    a.dishtype = 0
  WHERE
    a.parentkey = b.parentkey;

  ########################################## end: 如果后来单下的鱼，需要将此类的品项统计成单品#################################

  # 更新订单详情表中的菜品类别
  UPDATE t_temp_order_detail a, t_dish b
  SET
    a.dishtype = b.dishtype
  WHERE
    a.dishid = b.dishid
    AND a.dishtype IS NULL;

  #计算总的售卖份数
  SELECT ifnull(sum(dishnum), 0)
  INTO
    v_total_count
  FROM
    t_temp_order_detail;

  IF v_total_count <= 0 THEN
    SELECT NULL;
    SET po_errmsg = '数据为空，无查询结果';
    LEAVE label_main;
  END IF;

  #创建结果内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    columnid VARCHAR(50), # 菜品分类
    dishtype INT, #菜品属性，是单品还是鱼锅等
    title VARCHAR(50), #菜品名称
    dishNo VARCHAR(50), #品项编号
    price DOUBLE(13, 2), #单价
    unit VARCHAR(50), #单位
    number DOUBLE(13, 2), #数量
    share DOUBLE(13, 2) #占比
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;


  #开始设置其他值
  OPEN cur_dish_detail;

read_loop:
  LOOP
    FETCH cur_dish_detail INTO v_dishid, v_unit, v_dishtype, v_dishclass, v_number, v_price;

    IF v_fetch_done THEN
      LEAVE read_loop;
    END IF;

    #获取编号
    SELECT dishNo
         , title
    INTO
      v_dishNo, v_title
    FROM
      t_dish
    WHERE
      dishid = v_dishid
    LIMIT
      1;

    INSERT INTO t_temp_res VALUES (v_dishclass, v_dishtype, v_title, v_dishNo, v_price, v_unit, v_number, round(v_number / v_total_count * 100, 2));
  END LOOP;
  COMMIT;
  #最后关闭游标.
  CLOSE cur_dish_detail;

  #对餐具进行特殊处理
  IF pi_pl = -1 OR pi_pl = 'DISHES_98' THEN
    SELECT sum(dishnum)
         , ifnull(max(orignalprice), 0)
    INTO
      @cnt, @price
    FROM
      t_temp_order_detail
    WHERE
      dishid = 'DISHES_98';

    SELECT ifnull(title, '餐具')
         , ifnull(dishno, '')
    INTO
      @title, @dishno
    FROM
      t_dish
    WHERE
      dishid = 'DISHES_98'
    LIMIT
      1;

    IF @cnt > 0 THEN
      INSERT INTO t_temp_res VALUES ('DISHES_98', 0, @title, @dishno, @price, '份', @cnt, round(@cnt / v_total_count * 100, 2));
    END IF;
  END IF;


  #返回结果集
  IF pi_pl != '-1' AND pi_pxlx != -1 THEN
    SELECT title
         , dishNo
         , price
         , unit
         , number
         , share
    FROM
      t_temp_res
    WHERE
      columnid = pi_pl
      AND dishtype = pi_pxlx;

  ELSEIF pi_pl = '-1' AND pi_pxlx != -1 THEN
    SELECT title
         , dishNo
         , price
         , unit
         , number
         , share
    FROM
      t_temp_res
    WHERE
      dishtype = pi_pxlx;

  ELSEIF pi_pl != '-1' AND pi_pxlx = -1 THEN
    SELECT title
         , dishNo
         , price
         , unit
         , number
         , share
    FROM
      t_temp_res
    WHERE
      columnid = pi_pl;

  ELSE
    SELECT title
         , dishNo
         , price
         , unit
         , number
         , share
    FROM
      t_temp_res;

  END IF;

#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_parentkey;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
END
$$

DROP PROCEDURE IF EXISTS p_report_tcmxb$$
CREATE PROCEDURE p_report_tcmxb(IN  pi_branchid INT(11), -- 分店id
                                IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                IN  pi_ksrq     DATETIME, -- 开始日期，
                                IN  pi_jsrq     DATETIME, -- 结束日期
                                IN  pi_dqym     INT, -- 当前页码 第一次进入时从0开始
                                IN  pi_myts     INT, -- 每页显示的条数
                                OUT po_errmsg   VARCHAR(100)
                                -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '退菜明细表'
label_main:
BEGIN
  -- 返回字段说明如下(8个字段)：
  -- 发生时间	订单号 菜品名称 份数 金额 退菜申请人 退菜授权人 退菜原因
  --
  -- 返回数据举例（返回值包含多条数据）：
  -- 2015/06/01 h2015006666 鸡蛋豆干 1 12 小明 老赵 客户投诉
  DECLARE v_date_start          DATETIME;
  DECLARE v_date_end            DATETIME;
  DECLARE v_increment_offset    INT;
  DECLARE v_increment_increment INT;

  #异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;


  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  IF pi_myts < 1 THEN
    SELECT NULL;
    SET po_errmsg = '每页显示记录条数不能少于1';
    LEAVE label_main;
  END IF;

  IF pi_dqym < -1 THEN
    SELECT NULL;
    SET po_errmsg = '当前页面只能输入大于-1的正整数';
    LEAVE label_main;
  END IF;

  #设置内存表的上限
  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;
  SET v_increment_offset = @@auto_increment_offset;
  SET v_increment_increment = @@auto_increment_increment;

  #处理开始结束时间
  SET v_date_start = pi_ksrq; # str_to_date(concat(date_format(pi_ksrq, '%Y-%m-%d'), '00:00:00'), '%Y-%m-%d %H:%i:%s');
  SET v_date_end = pi_jsrq; # str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;
  CREATE UNIQUE INDEX uix_t_temp_order_orderid ON t_temp_order (orderid);


  -- 创建临时退菜内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_tcb;
  CREATE TEMPORARY TABLE t_temp_tcb
  (
    --   temp_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    begintime DATETIME,
    orderid VARCHAR(50),
    dishid VARCHAR(50),
    dishnum DOUBLE(13, 2),
    amount DOUBLE(13, 2),
    username VARCHAR(50),
    discarduserid VARCHAR(50),
    discardreason VARCHAR(100)
  ) ENGINE = HEAP DEFAULT CHARSET = utf8;

  -- 向内存表中放值
  INSERT INTO t_temp_tcb
  SELECT b.begintime
       , b.orderid
       , b.dishid
       , b.dishnum
       , b.orderprice * b.dishnum
       , b.username
       , b.discarduserid
       , b.discardreason
  FROM
    t_temp_order a, t_order_detail_discard b
  WHERE
    a.orderid = b.orderid
    AND b.orderprice IS NOT NULL
  ORDER BY
    b.begintime DESC;

  -- 创建结果内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_re;
  CREATE TEMPORARY TABLE t_temp_re
  (
    temp_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    beginTime DATETIME,
    orderid VARCHAR(50),
    title VARCHAR(50),
    num DOUBLE(13, 2),
    amount DOUBLE(13, 2),
    waiter VARCHAR(50),
    discardusername VARCHAR(50),
    discardreason VARCHAR(100),
    PRIMARY KEY (temp_id)
  ) ENGINE = HEAP DEFAULT CHARSET = utf8;

  -- 向结果内存表中赋值
  INSERT INTO t_temp_re (beginTime, orderid, title, num, amount, waiter, discardusername, discardreason)
  SELECT b.begintime
       , b.orderid
       , c.title
       , b.dishnum
       , b.amount
       , b.username
       , b.discarduserid
       , b.discardreason
  FROM
    t_temp_tcb b, t_dish c
  WHERE
    b.dishid = c.dishid;


  #创建员工信息内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_user;
  CREATE TEMPORARY TABLE t_temp_user
  (
    job_number CHAR(10),
    name VARCHAR(32)
  ) ENGINE = HEAP DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_user
  SELECT a.job_number
       , b.name
  FROM
    t_b_employee a, t_b_user b
  WHERE
    a.user_id = b.id
    AND a.branch_id = pi_branchid;


  -- 更新退菜人
  UPDATE t_temp_re t, t_temp_user b
  SET
    t.waiter = b.name
  WHERE
    t.waiter = b.job_number;

  -- 更新授权人
  UPDATE t_temp_re t, t_temp_user b
  SET
    t.discardusername = b.name
  WHERE
    t.discardusername = b.job_number;

  -- 发生时间	订单号 菜品名称 份数 金额 退菜申请人 退菜授权人 退菜原因
  -- 将结果返回
  #SET @a = pi_dqym * pi_myts;
  IF pi_dqym > -1 THEN
    SET @a = v_increment_offset + pi_dqym * pi_myts * v_increment_increment - v_increment_increment;
    SET @b = pi_myts;
    PREPARE s1 FROM 'select date_format(beginTime, \'%Y-%m-%d %H:%i\') beginTime,orderid,title,num,amount,waiter,discardusername,discardreason from t_temp_re where temp_id > ? limit ?';
    EXECUTE s1 USING @a, @b;
  ELSE
    PREPARE s1 FROM 'select date_format(beginTime, \'%Y-%m-%d %H:%i\') beginTime,orderid,title,num,amount,waiter,discardusername,discardreason from t_temp_re';
    EXECUTE s1;
  END IF;

  DEALLOCATE PREPARE s1;

#及时释放内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_tcb;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_re;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_user;

END
$$

DROP PROCEDURE IF EXISTS p_report_xxsjtjb$$
CREATE PROCEDURE p_report_xxsjtjb(IN  pi_branchid INT(11), -- 分店id
                                  IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                  IN  pi_ksrq     DATETIME, -- 开始日期，
                                  IN  pi_jsrq     DATETIME, -- 结束日期
                                  IN  pi_cxlx     SMALLINT, -- 查询类型 1:应收金额 2:实收金额 3:结算人数 4:开台数
                                  IN  pi_qy       VARCHAR(50), -- 餐台所属区域 -1:全部 非-1:区域id
                                  OUT po_errmsg   VARCHAR(100)
                                  -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '详细数据统计表'
label_main:
BEGIN
  -- 返回字段说明如下(2个固定字段+不固定字段)：
  -- 区域 桌号 时间列1 时间列2 时间列3.....
  --
  -- 返回数据举例（返回值包含多条数据）：
  -- 大堂 1 22 33 44


  DECLARE v_date_start    DATETIME;
  DECLARE v_date_end      DATETIME;
  DECLARE v_date_interval DATETIME; #时间间隔  
  DECLARE v_loop_num      INT DEFAULT 0; #根据开始结束时间和显示类型，来设置循环次数
  DECLARE v_table_index   INT;
  DECLARE v_table_id      VARCHAR(50);
  DECLARE v_sql           VARCHAR(5000) DEFAULT '';

  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;

  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;


  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;

  #设置循环次数,处理开始结算时间
  SET v_date_start = str_to_date(concat(date_format(pi_ksrq, '%Y-%m-%d'), '00:00:00'), '%Y-%m-%d %H:%i:%s');
  SET v_date_end = str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');
  SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 DAY), INTERVAL 1 SECOND);
  SET v_loop_num = timestampdiff(DAY, v_date_start, v_date_end) + 1;

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    begintime DATETIME,
    tableid VARCHAR(50),
    womanNum INT,
    childNum INT,
    mannum INT
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
         , begintime
         , currenttableid
         , womanNum
         , childNum
         , mannum
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
         , begintime
         , currenttableid
         , womanNum
         , childNum
         , mannum
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;

  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);


  IF pi_cxlx = 1 THEN
    DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
    CREATE TEMPORARY TABLE t_temp_order_detail
    (
      orderid VARCHAR(50),
      dishnum DOUBLE(13, 2),
      orignalprice DOUBLE(13, 2),
      tableid VARCHAR(50),
      begintime DATETIME,
      childdishtype TINYINT,
      primarykey VARCHAR(50),
      superkey VARCHAR(50)
    ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

    # 向临时订单详情内存表中放值
    INSERT INTO t_temp_order_detail
    SELECT b.orderid
         , b.dishnum
         , b.orignalprice
         , a.tableid
         , a.begintime
         , b.childdishtype
         , b.primarykey
         , b.superkey
    FROM
      t_temp_order a, t_order_detail b
    WHERE
      a.orderid = b.orderid
      AND b.orignalprice > 0;

    # 删除套餐明细
    DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
    CREATE TEMPORARY TABLE t_temp_keys
    (
      primarykey VARCHAR(50)
    ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
    INSERT INTO t_temp_keys
    SELECT primarykey
    FROM
      t_temp_order_detail
    WHERE
      childdishtype = 2;

    DELETE
    FROM
      t_temp_order_detail
    USING
      t_temp_order_detail, t_temp_keys
    WHERE
      t_temp_order_detail.superkey = t_temp_keys.primarykey
      AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;

    CREATE INDEX ix_t_temp_order_detail_begintime ON t_temp_order_detail (begintime);

  #创建结算明细内存表
  ELSEIF pi_cxlx = 2 THEN
    DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
    CREATE TEMPORARY TABLE t_temp_settlement_detail
    (
      orderid VARCHAR(50),
      payway INT,
      payamount DOUBLE(13, 2),
      begintime DATETIME,
      tableid VARCHAR(50)
    ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

    #生产临时结算明细表数据
    INSERT INTO t_temp_settlement_detail
    SELECT b.orderid
         , b.payway
         , b.payamount
         , a.begintime
         , a.tableid
    FROM
      t_temp_order a, t_settlement_detail b
    WHERE
      a.orderid = b.orderid
      AND b.payway IN (0, 1, 5, 8, 13, 17, 18)  -- shangwenchao 2015/12/21 22:46:49 增加结算方式13
      AND b.payamount > 0;

    CREATE INDEX ix_t_temp_settlement_detail_begintime ON t_temp_settlement_detail (begintime);

    #创建会员消费内存表
    DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
    CREATE TEMPORARY TABLE t_temp_order_member
    (
      orderid VARCHAR(50),
      Inflated DOUBLE(13, 2),
      begintime DATETIME,
      tableid VARCHAR(50)
    ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

    #生成临时会员结算数据  
    INSERT INTO t_temp_order_member
    SELECT b.orderid
         , b.Inflated
         , a.begintime
         , a.tableid
    FROM
      t_temp_order a, t_order_member b
    WHERE
      a.orderid = b.orderid;
    CREATE INDEX ix_t_temp_order_member_begintime ON t_temp_order_member (begintime);
  END IF;


  #筛选桌子
  DROP TEMPORARY TABLE IF EXISTS t_temp_table;
  CREATE TEMPORARY TABLE t_temp_table
  (
    areaname VARCHAR(10),
    tableid VARCHAR(50),
    tableNo VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_qy = '-1' THEN
    INSERT INTO t_temp_table (areaname, tableid, tableNo)
    SELECT b.areaname
         , a.tableid
         , a.tableNo
    FROM
      t_table a, t_tablearea b
    WHERE
      a.areaid = b.areaid
      AND b.branchid = pi_branchid;
  ELSE
    INSERT INTO t_temp_table (areaname, tableid, tableNo)
    SELECT b.areaname
         , a.tableid
         , a.tableNo
    FROM
      t_table a, t_tablearea b
    WHERE
      a.areaid = b.areaid
      AND b.areaid = pi_qy
      AND b.branchid = pi_branchid;
  END IF;


  #创建结果集
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    areaname VARCHAR(10),
    tableid VARCHAR(50),
    stime VARCHAR(10),
    svalue DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;


  #创建虚增结果集
  DROP TEMPORARY TABLE IF EXISTS t_temp_inflated;
  CREATE TEMPORARY TABLE t_temp_inflated
  (
    tableid VARCHAR(50),
    stime VARCHAR(10),
    svalue DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #####################################遍历桌子及统计天数，生成结果数据##########################################
  WHILE v_loop_num > 0
  DO

    #统计应收
    IF pi_cxlx = 1 THEN
      INSERT INTO t_temp_res (tableid, stime, svalue)
      SELECT tableid
           , date_format(v_date_start, '%Y/%m/%d')
           , sum(dishnum * orignalprice)
      FROM
        t_temp_order_detail
      WHERE
        begintime BETWEEN v_date_start AND v_date_interval
      GROUP BY
        tableid;

    #统计实收
    ELSEIF pi_cxlx = 2 THEN
      INSERT INTO t_temp_res (tableid, stime, svalue)
      SELECT tableid
           , date_format(v_date_start, '%Y/%m/%d')
           , ifnull(sum(payamount), 0)
      FROM
        t_temp_settlement_detail
      WHERE
        begintime BETWEEN v_date_start AND v_date_interval
      GROUP BY
        tableid;

      INSERT INTO t_temp_inflated
      SELECT tableid
           , date_format(v_date_start, '%Y/%m/%d')
           , ifnull(sum(Inflated), 0)
      FROM
        t_temp_order_member
      WHERE
        begintime BETWEEN v_date_start AND v_date_interval
      GROUP BY
        tableid;

    #INSERT INTO t_temp_res (tableid, stime, svalue) VALUES (v_table_id, date_format(v_date_start, '%Y/%m/%d'), @shishou - @xuzeng);

    #统计结账人数
    ELSEIF pi_cxlx = 3 THEN
      INSERT INTO t_temp_res (tableid, stime, svalue)
      SELECT tableid
           , date_format(v_date_start, '%Y/%m/%d')
           , ifnull(sum(mannum + womanNum + childNum), 0)
      FROM
        t_temp_order
      WHERE
        begintime BETWEEN v_date_start AND v_date_interval
      GROUP BY
        tableid;

    #统计开台数据
    ELSEIF pi_cxlx = 4 THEN
      INSERT INTO t_temp_res (tableid, stime, svalue)
      SELECT tableid
           , date_format(v_date_start, '%Y/%m/%d')
           , count(1)
      FROM
        t_temp_order
      WHERE
        begintime BETWEEN v_date_start AND v_date_interval
      GROUP BY
        tableid;
    #退出程序
    ELSE
      SELECT NULL;
      SET po_errmsg = '显示类型输入有误 1:应收金额 2:实收金额 3:结算人数 4:开台数';
      LEAVE label_main;
    END IF;

    #动态拼装sql，为后面的返回数据做准备
    SET @date_start = date_format(v_date_start, '%Y/%m/%d');
    SET v_sql = concat(v_sql, ',max(case stime when \'', @date_start, '\' then svalue else 0 end) \'', @date_start, '\'');

    SET v_date_start = date_add(v_date_start, INTERVAL 1 DAY);
    SET v_date_interval = date_add(v_date_interval, INTERVAL 1 DAY);
    SET v_loop_num = v_loop_num - 1;
  END WHILE;


  #删除不需要统计的桌号
  DELETE t_temp_res
  FROM
    t_temp_res
  LEFT JOIN t_temp_table
  ON t_temp_res.tableid = t_temp_table.tableid
  WHERE
    t_temp_table.tableid IS NULL;

  #更新实收数据
  UPDATE t_temp_res a, t_temp_inflated b
  SET
    a.svalue = a.svalue - b.svalue
  WHERE
    a.tableid = b.tableid
    AND a.stime = b.stime;

  #更新桌号及区域名称
  UPDATE t_temp_res a, t_temp_table b
  SET
    a.areaname = b.areaname, a.tableid = b.tableNo
  WHERE
    a.tableid = b.tableid;

  #返回数据
  SET v_sql = concat('SELECT areaname, tableid', v_sql);
  SET v_sql = concat(v_sql, ' FROM t_temp_res GROUP BY areaname, tableid order by tableid-0,areaname');
  SET @sql_xxsj = v_sql;
  PREPARE s1 FROM @sql_xxsj;
  EXECUTE s1;
  DEALLOCATE PREPARE s1;

#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_table;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_inflated;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
END
$$


DROP PROCEDURE IF EXISTS p_report_yhhdmxb$$
CREATE PROCEDURE p_report_yhhdmxb(IN  pi_branchid INT(11), -- 分店id
                                  IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                  IN  pi_ksrq     DATETIME, -- 开始日期，
                                  IN  pi_jsrq     DATETIME, -- 结束日期
                                  IN  pi_hdmc     VARCHAR(50), -- 活动名称 -1:全部  非-1:对应的活动名称
                                  IN  pi_jsfs     INT, -- 计算方式 -1:全部  5:挂账 6:优免
                                  IN  pi_hdlx     VARCHAR(10), -- 活动类型 -1:全部 99:雅座优惠券 其他值:活动类型code
                                  OUT po_errmsg   VARCHAR(100)
                                  -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '优惠活动明细表'
label_main:
BEGIN
  -- 返回字段说明如下(7个字段)：
  -- 活动名称	结算方式 活动类型 发生笔数 发生金额 拉动应收 拉动实收
  --
  -- 返回数据举例（返回值包含多条数据）：
  -- 点评88抵100 挂账 团购券 3 264 550 505
  -- 美团40元鱼券 挂账 团购券 4 364 650 605

  DECLARE v_date_start   DATETIME;
  DECLARE v_date_end     DATETIME;
  DECLARE v_loop_index   INT;
  DECLARE v_pname        VARCHAR(50);
  DECLARE v_ptype        CHAR(4);
  DECLARE v_payway       INT;
  DECLARE v_shouldamount DOUBLE(13, 2);
  DECLARE v_paidinamount DOUBLE(13, 2);
  DECLARE v_inflated     DOUBLE(13, 2); #虚增
  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;

  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;

  #处理开始结束时间
  SET v_date_start = pi_ksrq; # str_to_date(concat(date_format(pi_ksrq, '%Y-%m-%d'), '00:00:00'), '%Y-%m-%d %H:%i:%s');
  SET v_date_end = pi_jsrq; #str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;
  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);

  #创建订单详情内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT b.orderid
       , b.dishnum
       , b.orignalprice
       , b.childdishtype
       , b.primarykey
       , b.superkey
  FROM
    t_temp_order a, t_order_detail b
  WHERE
    a.orderid = b.orderid
    AND b.orignalprice > 0;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;

  CREATE INDEX ix_t_temp_order_detail_orderid ON t_temp_order_detail (orderid);

  #创建结算明细内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail
  (
    orderid VARCHAR(50),
    payway INT,
    payamount DOUBLE(13, 2),
    couponNum INT,
    bankcardno VARCHAR(50),
    coupondetailid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生产临时结算明细表数据
  INSERT INTO t_temp_settlement_detail
  SELECT b.orderid
       , b.payway
       , b.payamount
       , b.couponNum
       , b.bankcardno
       , b.coupondetailid
  FROM
    t_temp_order a, t_settlement_detail b
  WHERE
    a.orderid = b.orderid
    AND b.payamount > 0;
  #创建查询索引
  CREATE INDEX ix_t_temp_settlement_detail_payway ON t_temp_settlement_detail (payway);


  #创建结算明细内存表(只有实收数据)
  DROP TEMPORARY TABLE IF EXISTS t_temp_paidinamout;
  CREATE TEMPORARY TABLE t_temp_paidinamout
  (
    orderid VARCHAR(50),
    payamount DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生产临时结算明细表数据
  INSERT INTO t_temp_paidinamout
  SELECT orderid
       , payamount
  FROM
    t_temp_settlement_detail
  WHERE
    payway IN (0, 1, 5, 8, 13, 17, 18); -- SHANGWENCHAO 2015/12/21 23:28:59 增加结算方式13
  CREATE INDEX ix_t_temp_paidinamout_orderid ON t_temp_paidinamout (orderid);


  #创建会员消费内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
  CREATE TEMPORARY TABLE t_temp_order_member
  (
    orderid VARCHAR(50),
    Inflated DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生成临时会员结算数据  
  INSERT INTO t_temp_order_member
  SELECT b.orderid
       , b.Inflated
  FROM
    t_temp_order a, t_order_member b
  WHERE
    a.orderid = b.orderid;
  CREATE INDEX ix_t_temp_order_member_orderid ON t_temp_order_member (orderid);


  #创建优惠活动内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_preferential;
  CREATE TEMPORARY TABLE t_temp_preferential
  (
    pid VARCHAR(50),
    pname VARCHAR(128),
    ptype CHAR(4),
    ptypename VARCHAR(32)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #生成正常的优惠券数据，包括将其他优惠中的具体原因和合作单位也看成单独的优惠
  INSERT INTO t_temp_preferential
  SELECT a.id
       , (
         CASE
         WHEN a.preferential = a.id THEN
           b.name
         ELSE
           ifnull(ifnull(a.free_reason, a.company_name), b.name)
         END) AS name
       , CASE
         WHEN b.type = '06' THEN
           b.sub_type
         ELSE
           b.type
         END
       , CASE
         WHEN b.type = '06' THEN
           b.sub_type_name
         ELSE
           b.type_name
         END
  FROM
    t_p_preferential_detail a, t_p_preferential_activity b
  WHERE
    a.preferential = b.id;

  ##############################################根据选择，生成中间临时数据####################################
  DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
  CREATE TEMPORARY TABLE t_temp_res_detail
  (
    orderid VARCHAR(50),
    payway INT, #结算方式
    payamount DOUBLE(13, 2), #结算金额
    couponNum INT, #使用数量
    pname VARCHAR(128), #活动名称
    ptype CHAR(4), #活动分类
    ptypename VARCHAR(32) #活动分类名称
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #生成挂账和优免数据（不包含金总挂账数据）
  INSERT INTO t_temp_res_detail
  SELECT a.orderid
       , a.payway
       , a.payamount
       , a.couponNum
       , b.pname
       , b.ptype
       , b.ptypename
  FROM
    t_temp_settlement_detail a, t_temp_preferential b
  WHERE
    a.payway IN (5, 6)
    AND a.coupondetailid = b.pid;

  --   #生成金总挂账优免数据
  --   INSERT INTO t_temp_res_detail
  --   SELECT a.orderid
  --        , 6
  --        , a.payamount
  --        , 1
  --        , '金总挂账'
  --        , '0601'
  --        , '手工优免'
  --   FROM
  --     t_temp_settlement_detail a
  --   WHERE
  --     a.payway = 13;

  #生成雅座优惠券数据
  INSERT INTO t_temp_res_detail
  SELECT a.orderid
       , 6
       , a.payamount
       , a.couponNum
       , a.bankcardno
       , '99'
       , '雅座优惠券'
  FROM
    t_temp_settlement_detail a
  WHERE
    a.payway = 12;
  CREATE INDEX ix_t_temp_res_detail ON t_temp_res_detail (pname, ptype, payway);

  ##############################################生成最终结果数据####################################
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    pname VARCHAR(128), #活动名称
    ptype CHAR(4), #活动分类
    ptypename VARCHAR(32), #活动分类名称
    payway INT, #结算方式
    paywaydesc VARCHAR(50), #结算方式名称
    couponNum INT, #使用数量
    payamount DOUBLE(13, 2), #发生金额
    shouldamount DOUBLE(13, 2), #应收
    paidinamount DOUBLE(13, 2), #实收
    PRIMARY KEY (id)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;


  INSERT INTO t_temp_res (pname, ptype, payway, couponNum, payamount)
  SELECT pname
       , ptype
       , payway
       , ifnull(sum(couponNum), 0)
       , ifnull(sum(payamount), 0)
  FROM
    t_temp_res_detail
  GROUP BY
    pname
  , ptype
  , payway;

  DROP TEMPORARY TABLE IF EXISTS t_temp_orderid;
  CREATE TEMPORARY TABLE t_temp_orderid
  (
    orderid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;


  #获取自增长字段的偏移量和自增量，以及自增字段的最大值
  SET @offset = @@auto_increment_offset;
  SET @increment = @@auto_increment_increment;
  SELECT ifnull(max(id), 0)
  INTO
    @maxid
  FROM
    t_temp_res;

lable_loop:
  LOOP
    #循环结束标识
    IF @offset > @maxid THEN
      LEAVE lable_loop;
    END IF;

    SELECT pname
         , ptype
         , payway
    INTO
      v_pname, v_ptype, v_payway
    FROM
      t_temp_res
    WHERE
      id = @offset;


    TRUNCATE t_temp_orderid;

    #获取订单列表
    INSERT INTO t_temp_orderid
    SELECT DISTINCT orderid
    FROM
      t_temp_res_detail
    WHERE
      pname = v_pname
      AND ptype = v_ptype
      AND payway = v_payway;

    #计算拉动应收
    SELECT ifnull(sum(a.orignalprice * a.dishnum), 0)
    INTO
      v_shouldamount
    FROM
      t_temp_order_detail a, t_temp_orderid b
    WHERE
      a.orderid = b.orderid;

    #计算拉动实收(含虚增)
    SELECT ifnull(sum(a.payamount), 0)
    INTO
      v_paidinamount
    FROM
      t_temp_paidinamout a, t_temp_orderid b
    WHERE
      a.orderid = b.orderid;

    #计算虚增
    SELECT ifnull(sum(a.Inflated), 0)
    INTO
      v_inflated
    FROM
      t_temp_order_member a, t_temp_orderid b
    WHERE
      a.orderid = b.orderid;

    #更新结果数据
    UPDATE t_temp_res
    SET
      shouldamount = v_shouldamount, paidinamount = v_paidinamount - v_inflated
    WHERE
      id = @offset;

    #获取下一个自增id值
    SET @offset = @offset + @increment;
  END LOOP;


  #更新支付方式名称
  UPDATE t_temp_res a, t_dictionary b
  SET
    a.paywaydesc = b.itemDesc
  WHERE
    a.payway = b.itemid
    AND type = 'PAYWAY';

  #更新活动类型名称
  UPDATE t_temp_res a, t_temp_preferential b
  SET
    a.ptypename = b.ptypename
  WHERE
    a.ptype = b.ptype;

  #更新雅座优惠券活动类型
  UPDATE t_temp_res a
  SET
    a.ptypename = '雅座优惠券'
  WHERE
    a.ptype = '99';

  #根据用户选择，删除多余的数据
  IF pi_hdmc != '-1' THEN
    DELETE
    FROM
      t_temp_res
    WHERE
      pname != pi_hdmc;
  END IF;

  IF pi_jsfs != -1 THEN
    DELETE
    FROM
      t_temp_res
    WHERE
      payway != pi_jsfs;
  END IF;

  IF pi_hdlx != '-1' THEN
    DELETE
    FROM
      t_temp_res
    WHERE
      ptype != pi_hdlx;
  END IF;


  #返回结果集
  SELECT pname
       , #活动名称
         ptype
       , #活动分类编码
         ptypename
       , #活动分类名称
         payway
       , #结算方式编码
         paywaydesc
       , #结算方式名称
         couponNum
       , #使用数量
         payamount
       , #发生金额
         shouldamount
       , #应收
         paidinamount #实收
  FROM
    t_temp_res;



#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_paidinamout;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_preferential;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_orderid;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
END
$$


DROP PROCEDURE IF EXISTS p_report_yhhdmxb_zhixiang$$
CREATE PROCEDURE p_report_yhhdmxb_zhixiang(IN  pi_branchid INT(11), -- 分店id
                                           IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                           IN  pi_ksrq     DATETIME, -- 开始日期，
                                           IN  pi_jsrq     DATETIME, -- 结束日期
                                           IN  pi_hdmc     VARCHAR(50), -- 活动名称
                                           IN  pi_jsfs     INT, -- 计算方式 5:挂账 6:优免
                                           IN  pi_hdlx     VARCHAR(10), -- 活动类型 99:雅座优惠券 其他值:活动类型code
                                           IN  pi_dqy      INT, -- 当前页码 第一次进入时从0开始
                                           IN  pi_myts     INT, -- 每页显示的条数
                                           OUT po_errmsg   VARCHAR(100)
                                           -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '优惠活动明细表-子项'
label_main:
BEGIN -- 返回字段说明如下(7个字段)：
  -- 发生时间	订单号 结算金额 发生笔数 发生金额 拉动应收 拉动实收
  --
  -- 返回数据举例（返回值包含多条数据）：
  -- 2015/06/01 h2015006666 88 3 264 550 505
  -- 2015/06/01 h2016006666 88 3 264 550 505

  DECLARE v_date_start          DATETIME;
  DECLARE v_date_end            DATETIME;
  DECLARE v_loop_index          INT;
  DECLARE v_pname               VARCHAR(50);
  DECLARE v_ptype               CHAR(4);
  DECLARE v_payway              INT;
  DECLARE v_shouldamount        DOUBLE(13, 2);
  DECLARE v_paidinamount        DOUBLE(13, 2);
  DECLARE v_inflated            DOUBLE(13, 2); #虚增
  DECLARE v_fetch_done          BOOL DEFAULT FALSE; #游标结束标识
  DECLARE v_increment_offset    INT;
  DECLARE v_increment_increment INT;



  #定义一个优惠活动的游标
  DECLARE cur_p_detail CURSOR FOR SELECT DISTINCT pname
                                                , ptype
                                                , payway
                                  FROM
                                    t_temp_res_detail;

  #游标结束时的处理程序
  DECLARE CONTINUE HANDLER FOR NOT FOUND
  BEGIN
    SET v_fetch_done = TRUE; #当读到数据的最后一条时,设置v_fetch_done变量为TRUE
  END;

  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;


  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  IF pi_myts < 1 THEN
    SELECT NULL;
    SET po_errmsg = '每页显示记录条数不能少于1';
    LEAVE label_main;
  END IF;

  IF pi_dqy < -1 THEN
    SELECT NULL;
    SET po_errmsg = '当前页面只能输入大于-1的正整数';
    LEAVE label_main;
  END IF;


  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;
  SET v_increment_offset = @@auto_increment_offset;
  SET v_increment_increment = @@auto_increment_increment;

  #处理开始结束时间
  SET v_date_start = pi_ksrq; # str_to_date(concat(date_format(pi_ksrq, '%Y-%m-%d'), '00:00:00'), '%Y-%m-%d %H:%i:%s');
  SET v_date_end = pi_jsrq; #str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
         , begintime
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
         , begintime
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;
  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);

  #创建订单详情内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT b.orderid
       , b.dishnum
       , b.orignalprice
       , b.childdishtype
       , b.primarykey
       , b.superkey
  FROM
    t_temp_order a, t_order_detail b
  WHERE
    a.orderid = b.orderid;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;

  CREATE INDEX ix_t_temp_order_detail_orderid ON t_temp_order_detail (orderid);

  #创建结算明细内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail
  (
    orderid VARCHAR(50),
    payway INT,
    payamount DOUBLE(13, 2),
    couponNum INT,
    bankcardno VARCHAR(50),
    coupondetailid VARCHAR(50),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生产临时结算明细表数据
  INSERT INTO t_temp_settlement_detail
  SELECT b.orderid
       , b.payway
       , b.payamount
       , b.couponNum
       , b.bankcardno
       , b.coupondetailid
       , a.begintime
  FROM
    t_temp_order a, t_settlement_detail b
  WHERE
    a.orderid = b.orderid
    AND b.payamount > 0;
  #创建查询索引
  CREATE INDEX ix_t_temp_settlement_detail_orderid ON t_temp_settlement_detail (orderid);

  #创建会员消费内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
  CREATE TEMPORARY TABLE t_temp_order_member
  (
    orderid VARCHAR(50),
    Inflated DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生成临时会员结算数据  
  INSERT INTO t_temp_order_member
  SELECT b.orderid
       , b.Inflated
  FROM
    t_temp_order a, t_order_member b
  WHERE
    a.orderid = b.orderid;
  CREATE INDEX ix_t_temp_order_member_orderid ON t_temp_order_member (orderid);


  #创建优惠活动内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_preferential;
  CREATE TEMPORARY TABLE t_temp_preferential
  (
    pid VARCHAR(50),
    pname VARCHAR(128),
    ptype CHAR(4),
    ptypename VARCHAR(32)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #生成正常的优惠券数据，包括将其他优惠中的具体原因和合作单位也看成单独的优惠
  INSERT INTO t_temp_preferential
  SELECT a.id
       , (
         CASE
         WHEN a.preferential = a.id THEN
           b.name
         ELSE
           ifnull(ifnull(a.free_reason, a.company_name), b.name)
         END) AS name
       , CASE
         WHEN b.type = '06' THEN
           b.sub_type
         ELSE
           b.type
         END
       , CASE
         WHEN b.type = '06' THEN
           b.sub_type_name
         ELSE
           b.type_name
         END
  FROM
    t_p_preferential_detail a, t_p_preferential_activity b
  WHERE
    a.preferential = b.id;

  ##############################################根据选择，生成中间临时数据####################################
  DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
  CREATE TEMPORARY TABLE t_temp_res_detail
  (
    orderid VARCHAR(50),
    payway INT, #结算方式
    payamount DOUBLE(13, 2), #结算金额
    couponNum INT, #使用数量
    pname VARCHAR(128), #活动名称
    ptype CHAR(4), #活动分类
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #生成挂账和优免数据（不包含金总挂账数据）
  INSERT INTO t_temp_res_detail
  SELECT a.orderid
       , a.payway
       , a.payamount
       , a.couponNum
       , b.pname
       , b.ptype
       , a.begintime
  FROM
    t_temp_settlement_detail a, t_temp_preferential b
  WHERE
    a.payway IN (5, 6)
    AND a.coupondetailid = b.pid;

  #生成金总挂账优免数据
  --   INSERT INTO t_temp_res_detail
  --   SELECT a.orderid
  --        , 6
  --        , a.payamount
  --        , 1
  --        , '金总挂账'
  --        , '0601'
  --        , a.begintime
  --   FROM
  --     t_temp_settlement_detail a
  --   WHERE
  --     a.payway = 13;

  #生成雅座优惠券数据
  INSERT INTO t_temp_res_detail
  SELECT a.orderid
       , 6
       , a.payamount
       , a.couponNum
       , a.bankcardno
       , '99'
       , a.begintime
  FROM
    t_temp_settlement_detail a
  WHERE
    a.payway = 12;

  ##############################################删除多余数据#######################################
  IF pi_hdmc != '-1' THEN
    DELETE
    FROM
      t_temp_res_detail
    WHERE
      pname != pi_hdmc;
  END IF;

  IF pi_jsfs != -1 THEN
    DELETE
    FROM
      t_temp_res_detail
    WHERE
      payway != pi_jsfs;
  END IF;

  IF pi_hdlx != '-1' THEN
    DELETE
    FROM
      t_temp_res_detail
    WHERE
      ptype != pi_hdlx;
  END IF;
  CREATE INDEX ix_t_temp_res_detail ON t_temp_res_detail (pname, ptype, payway);


  ##############################################生成最终结果数据####################################
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    temp_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    begintime CHAR(10),
    orderid VARCHAR(50),
    price DOUBLE(13, 2),
    couponNum INT, #使用数量
    payamount DOUBLE(13, 2), #发生金额
    shouldamount DOUBLE(13, 2), #应收
    paidinamount DOUBLE(13, 2), #实收
    PRIMARY KEY (temp_id)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;



  #开始统计每条优惠的数据
  OPEN cur_p_detail;

lable_fetch_loop:
  LOOP

    FETCH cur_p_detail INTO v_pname, v_ptype, v_payway;
    IF v_fetch_done THEN
      LEAVE lable_fetch_loop;
    END IF;
    INSERT INTO t_temp_res (begintime, orderid, price, couponNum, payamount, shouldamount, paidinamount)
    SELECT date_format(max(begintime), '%Y-%m-%d')
         , orderid
         , max(payamount)
         , ifnull(sum(couponNum), 0)
         , ifnull(sum(payamount), 0)
         , 0
         , 0
    FROM
      t_temp_res_detail
    WHERE
      pname = v_pname
      AND ptype = v_ptype
      AND payway = v_payway
    GROUP BY
      orderid;
  END LOOP;
  #最后关闭游标.
  CLOSE cur_p_detail;


  #生成优惠对应的订单号的内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_orderid;
  CREATE TEMPORARY TABLE t_temp_orderid
  (
    orderid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_orderid
  SELECT DISTINCT orderid
  FROM
    t_temp_res;

  #生成应收表
  DROP TEMPORARY TABLE IF EXISTS t_temp_shouldamount;
  CREATE TEMPORARY TABLE t_temp_shouldamount
  (
    orderid VARCHAR(50),
    shouldamount DOUBLE(13, 2) #应收
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_shouldamount
  SELECT a.orderid
       , sum(a.orignalprice * a.dishnum)
  FROM
    t_temp_order_detail a, t_temp_orderid b
  WHERE
    a.orderid = b.orderid
  GROUP BY
    a.orderid;

  #生成虚增表
  DROP TEMPORARY TABLE IF EXISTS t_temp_inflated;
  CREATE TEMPORARY TABLE t_temp_inflated
  (
    orderid VARCHAR(50),
    inflated DOUBLE(13, 2) #应收
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_inflated
  SELECT a.orderid
       , ifnull(sum(a.Inflated), 0)
  FROM
    t_temp_order_member a, t_temp_orderid b
  WHERE
    a.orderid = b.orderid
  GROUP BY
    a.orderid;

  #生成实收表
  DROP TEMPORARY TABLE IF EXISTS t_temp_paidinamount;
  CREATE TEMPORARY TABLE t_temp_paidinamount
  (
    orderid VARCHAR(50),
    paidinamount DOUBLE(13, 2) #应收
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_paidinamount
  SELECT a.orderid
       , ifnull(sum(a.payamount), 0)
  FROM
    t_temp_settlement_detail a, t_temp_orderid b
  WHERE
    a.orderid = b.orderid
    AND payway IN (0, 1, 5, 8, 13, 17, 18)  -- SHANGWENCHAO 2015/12/21 23:28:59 增加结算方式13
  GROUP BY
    a.orderid;

  #更新实收表
  UPDATE t_temp_paidinamount a, t_temp_inflated b
  SET
    a.paidinamount = a.paidinamount - b.inflated
  WHERE
    a.orderid = b.orderid;


  #更新结果集（应收）
  UPDATE t_temp_res a, t_temp_shouldamount b
  SET
    a.shouldamount = b.shouldamount
  WHERE
    a.orderid = b.orderid;

  #更新结果集（实收）
  UPDATE t_temp_res a, t_temp_paidinamount b
  SET
    a.paidinamount = b.paidinamount
  WHERE
    a.orderid = b.orderid;


  #返回结果集
  #SET @a = pi_dqy * pi_myts;
  IF pi_dqy > -1 THEN
    SET @a = v_increment_offset + pi_dqy * pi_myts * v_increment_increment - v_increment_increment;
    SET @b = pi_myts;
    PREPARE s1 FROM 'SELECT begintime,orderid,price,couponNum,payamount,shouldamount,paidinamount FROM t_temp_res where temp_id > ? limit ?';
    EXECUTE s1 USING @a, @b;
  ELSE
    PREPARE s1 FROM 'SELECT begintime,orderid,price,couponNum,payamount,shouldamount,paidinamount FROM t_temp_res';
    EXECUTE s1;
  END IF;
  DEALLOCATE PREPARE s1;



#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_preferential;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_orderid;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_shouldamount;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_paidinamount;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_inflated;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
END
$$


DROP PROCEDURE IF EXISTS p_report_yyfx_pxxstj$$
CREATE PROCEDURE p_report_yyfx_pxxstj(IN  pi_branchid INT(11), -- 分店id
                                      IN  pi_xslx     SMALLINT, -- 显示类别 0:日  1:月  2:年
                                      IN  pi_ksrq     DATETIME, -- 开始日期
                                      IN  pi_jsrq     DATETIME, -- 结束日期
                                      OUT po_errmsg   VARCHAR(100)
                                      -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '营业分析_品项销售统计'
label_main:
BEGIN
  -- 返回字段说明如下（4个字段）：
  -- 类别（0:份数；1:金额），菜名，汇总值，拆分值（格式为：时间,数值|时间,数值|时间,数值|时间,数值|....） 
  --
  -- 返回数据举例（多行数据）：
  -- 0  红汤梭边鱼  100  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 0  青柠巴沙鱼  98  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 0  凉菜四拼  300  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 1  红汤梭边鱼  100  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 1  青柠巴沙鱼  98  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 1  凉菜四拼  300  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9

  DECLARE v_date_start    DATETIME;
  DECLARE v_date_end      DATETIME;
  DECLARE v_date_interval DATETIME; #时间间隔  
  DECLARE v_statistictime VARCHAR(15); #统计日期
  DECLARE v_dishid        VARCHAR(50);
  DECLARE v_dishunit      VARCHAR(50);
  DECLARE v_showtype      TINYINT;
  DECLARE v_value_detail  VARCHAR(1000);
  DECLARE v_loop_num      INT DEFAULT 0; #根据开始结束时间和显示类型，来设置循环次数

  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;


  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  #设置临时内存表
  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;

  #设置循环次数,处理开始结算时间
  IF pi_xslx = 0 THEN
    SET v_statistictime = date_format(pi_ksrq, '%Y-%m-%d');
    SET v_date_start = str_to_date(concat(v_statistictime, '00:00:00'), '%Y-%m-%d %H:%i:%s');
    SET v_date_end = str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');
    SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 DAY), INTERVAL 1 SECOND);
    SET v_loop_num = timestampdiff(DAY, v_date_start, v_date_end) + 1;
  ELSEIF pi_xslx = 1 THEN
    SET v_statistictime = date_format(pi_ksrq, '%Y-%m');
    SET v_date_start = str_to_date(concat(v_statistictime, '-01 00:00:00'), '%Y-%m-%d %H:%i:%s');
    SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 MONTH), INTERVAL 1 SECOND);
    SET v_date_end = date_sub(date_add(str_to_date(concat(date_format(pi_jsrq, '%Y-%m'), '-01 00:00:00'), '%Y-%m-%d %H:%i:%s'), INTERVAL 1 MONTH), INTERVAL 1 SECOND);
    SET v_loop_num = timestampdiff(MONTH, v_date_start, v_date_end) + 1;
  ELSE
    SELECT NULL;
    LEAVE label_main;
  END IF;

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_order
  SELECT orderid
       , begintime
  FROM
    t_order USE INDEX (IX_t_order_begintime)
  WHERE
    branchid = pi_branchid
    AND begintime BETWEEN v_date_start AND v_date_end # 需要创建索引IX_t_order_begintime  
    AND orderstatus = 3;

  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);
  CREATE INDEX ix_t_temp_order_begintime ON t_temp_order (begintime);

  #创建订单详情临时内存表（方便计算应收）
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishid VARCHAR(50),
    dishunit VARCHAR(10),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    begintime DATETIME,
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  # 向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT b.orderid
       , b.dishid
       , b.dishunit
       , b.dishnum
       , b.orignalprice
       , a.begintime
       , b.childdishtype
       , b.primarykey
       , b.superkey
  FROM
    t_temp_order a, t_order_detail b
  WHERE
    a.orderid = b.orderid
    AND b.orignalprice > 0;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;

  #为订单详情表创建索引
  CREATE INDEX ix_t_temp_order_detail_begintime ON t_temp_order_detail (begintime);

  #创建中间临时表
  DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
  CREATE TEMPORARY TABLE t_temp_res_detail
  (
    statistictime VARCHAR(20),
    dishid VARCHAR(50),
    dishunit VARCHAR(10),
    dishnum INT,
    dishprice DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #循环计算所需的数据
  WHILE v_loop_num > 0
  DO
    INSERT INTO t_temp_res_detail
    SELECT v_statistictime
         , dishid
         , dishunit
         , sum(dishnum)
         , sum(dishnum * orignalprice)
    FROM
      t_temp_order_detail USE INDEX (ix_t_temp_order_detail_begintime)
    WHERE
      begintime BETWEEN v_date_start AND v_date_interval
    GROUP BY
      dishid
    , dishunit
    ORDER BY
      NULL;


    IF pi_xslx = 0 THEN
      SET v_date_start = date_add(v_date_start, INTERVAL 1 DAY);
      SET v_date_interval = date_add(v_date_interval, INTERVAL 1 DAY);
      SET v_statistictime = date_format(v_date_start, '%Y-%m-%d');
    ELSE
      SET v_date_start = date_add(v_date_start, INTERVAL 1 MONTH);
      SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 MONTH), INTERVAL 1 SECOND);
      SET v_statistictime = date_format(v_date_start, '%Y-%m');
    END IF;

    SET v_loop_num = v_loop_num - 1;
  END WHILE;
  #为临时表创建索引
  CREATE INDEX ix_t_temp_res_detail_dishid ON t_temp_res_detail (dishid);

  #餐具不参与统计
  DELETE
  FROM
    t_temp_res_detail
  WHERE
    dishid = 'DISHES_98';


  #创建结果内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    showtype TINYINT,
    dishid VARCHAR(50),
    dishunit VARCHAR(50),
    total_num INT,
    detail_num VARCHAR(1000),
    PRIMARY KEY (id)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #售卖份数TOP10
  INSERT INTO t_temp_res (showtype, dishid, dishunit, total_num)
  SELECT 0
       , dishid
       , dishunit
       , sum(dishnum)
  FROM
    t_temp_res_detail
  GROUP BY
    dishid
  , dishunit
  ORDER BY
    sum(dishnum) DESC
  LIMIT
    10;

  #售卖金额TOP10
  INSERT INTO t_temp_res (showtype, dishid, dishunit, total_num)
  SELECT 1
       , dishid
       , dishunit
       , sum(dishprice)
  FROM
    t_temp_res_detail
  GROUP BY
    dishid
  , dishunit
  ORDER BY
    sum(dishprice) DESC
  LIMIT
    10;


  #获取自增长字段的偏移量和自增量，以及自增字段的最大值
  SET @offset = @@auto_increment_offset;
  SET @increment = @@auto_increment_increment;
  SELECT ifnull(max(id), 0)
  INTO
    @maxid
  FROM
    t_temp_res;

#组装每天（每月）拆分的值
  loop_lable1:
  LOOP

    #循环结束标识
    IF @offset > @maxid THEN
      LEAVE loop_lable1;
    END IF;

    SELECT showtype
         , dishid
         , dishunit
    INTO
      v_showtype, v_dishid, v_dishunit
    FROM
      t_temp_res
    WHERE
      id = @offset;


    IF v_showtype = 0 THEN
      SELECT group_concat(t.value_detail SEPARATOR '|')
      INTO
        v_value_detail
      FROM
        (
        SELECT concat(statistictime, ',', dishnum) AS value_detail
        FROM
          t_temp_res_detail
        WHERE
          dishid = v_dishid
          AND dishunit = v_dishunit
        ORDER BY
          statistictime ASC) t;

    ELSEIF v_showtype = 1 THEN
      SELECT group_concat(t.value_detail SEPARATOR '|')
      INTO
        v_value_detail
      FROM
        (
        SELECT concat(statistictime, ',', dishprice) AS value_detail
        FROM
          t_temp_res_detail
        WHERE
          dishid = v_dishid
          AND dishunit = v_dishunit
        ORDER BY
          statistictime ASC) t;
    ELSE
      LEAVE loop_lable1;
    END IF;

    #设置拆分值
    UPDATE t_temp_res
    SET
      detail_num = v_value_detail
    WHERE
      id = @offset;

    #获取下一个自增id值
    SET @offset = @offset + @increment;
  END LOOP;
  -- 

  #返回结果
  SELECT a.showtype
       , concat(b.title, '(', a.dishunit, ')') title
       , a.total_num
       , a.detail_num
  FROM
    t_temp_res a, t_dish b
  WHERE
    a.dishid = b.dishid;



#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;

END
$$

DROP PROCEDURE IF EXISTS p_report_yyfx_yhhdtj$$
CREATE PROCEDURE p_report_yyfx_yhhdtj(IN  pi_branchid INT(11), -- 分店id
                                      IN  pi_xslx     SMALLINT, -- 显示类别 0:日  1:月  2:年
                                      IN  pi_ksrq     DATETIME, -- 开始日期
                                      IN  pi_jsrq     DATETIME, -- 结束日期
                                      IN  pi_tjx      SMALLINT, -- 统计项：0:活动名称  1:活动类别
                                      OUT po_errmsg   VARCHAR(100)
                                      -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '营业分析_优惠活动统计'
label_main:
BEGIN
  -- 返回字段说明如下（4个字段）：
  -- 类别（0:笔数；1:金额；2:应收；3:实收），名称，汇总值，拆分值（格式为：时间,数值|时间,数值|时间,数值|时间,数值|....） 
  --
  -- 返回数据举例（多行数据）：
  -- 0  1元尝鲜  100  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 0  美团券  98  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 1  1元尝鲜  1806  6.1,151|6.2,131|6.3,81|6.4,10|6.5,141|6.6,71|6.7,91
  -- 1  美团券  7896  6.1,15|6.2,132|6.3,82|6.4,20|6.5,214|6.6,72|6.7,92
  -- 2  1元尝鲜  10000  6.1,15|6.2,1300|6.3,800|6.4,100|6.5,1400|6.6,700|6.7,900
  -- 2  美团券  20000  6.1,15|6.2,1300|6.3,899|6.4,299|6.5,1499|6.6,799|6.7,999
  -- 3  1元尝鲜  8888  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9
  -- 3  美团券  9999  6.1,15|6.2,13|6.3,8|6.4,0|6.5,14|6.6,7|6.7,9

  DECLARE v_date_start    DATETIME;
  DECLARE v_date_end      DATETIME;
  DECLARE v_date_interval DATETIME; #时间间隔  
  DECLARE v_statistictime VARCHAR(15); #统计日期
  DECLARE v_loop_num      INT DEFAULT 0; #根据开始结束时间和显示类型，来设置循环次数
  DECLARE v_fetch_done    BOOL DEFAULT FALSE;
  DECLARE v_pname         VARCHAR(128); #活动名称
  DECLARE v_ptype         CHAR(4); #活动分类编码
  DECLARE v_pcount        INT UNSIGNED; #活动发生笔数
  DECLARE v_pamount       DOUBLE(13, 2); #活动发生金额
  DECLARE v_shouldamount  DOUBLE(13, 2); #活动拉动应收
  DECLARE v_paidinacount  DOUBLE(13, 2); #活动拉动实收（含虚增）
  DECLARE v_inflated      DOUBLE(13, 2); #虚增量
  DECLARE v_showtype      TINYINT; #统计项（0:笔数；1:金额；2:应收；3:实收）
  DECLARE v_value_detail  VARCHAR(1000);

  DECLARE CONTINUE HANDLER FOR NOT FOUND
  BEGIN
    SET v_fetch_done = TRUE; #当读到数据的最后一条时,设置v_fetch_done变量为TRUE
  END;

  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;

  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  IF pi_tjx NOT IN (0, 1) THEN
    SET po_errmsg = '统计项参数输入有误：0:活动名称  1:活动类别';
    SELECT NULL;
    LEAVE label_main;
  END IF;

  #设置临时内存表
  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;

  #设置循环次数,处理开始结算时间
  IF pi_xslx = 0 THEN
    SET v_statistictime = date_format(pi_ksrq, '%Y-%m-%d');
    SET v_date_start = str_to_date(concat(v_statistictime, '00:00:00'), '%Y-%m-%d %H:%i:%s');
    SET v_date_end = str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');
    SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 DAY), INTERVAL 1 SECOND);
    SET v_loop_num = timestampdiff(DAY, v_date_start, v_date_end) + 1;
  ELSEIF pi_xslx = 1 THEN
    SET v_statistictime = date_format(pi_ksrq, '%Y-%m');
    SET v_date_start = str_to_date(concat(v_statistictime, '-01 00:00:00'), '%Y-%m-%d %H:%i:%s');
    SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 MONTH), INTERVAL 1 SECOND);
    SET v_date_end = date_sub(date_add(str_to_date(concat(date_format(pi_jsrq, '%Y-%m'), '-01 00:00:00'), '%Y-%m-%d %H:%i:%s'), INTERVAL 1 MONTH), INTERVAL 1 SECOND);
    SET v_loop_num = timestampdiff(MONTH, v_date_start, v_date_end) + 1;
  ELSE
    SELECT NULL;
    SET po_errmsg = '显示类别输入有误，0:日 1:月 2:年';
    LEAVE label_main;
  END IF;


  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_order
  SELECT orderid
       , begintime
  FROM
    t_order USE INDEX (IX_t_order_begintime)
  WHERE
    branchid = pi_branchid
    AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
    AND orderstatus = 3;

  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);

  #创建订单详情内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT b.orderid
       , b.dishnum
       , b.orignalprice
       , b.childdishtype
       , b.primarykey
       , b.superkey
  FROM
    t_temp_order a, t_order_detail b
  WHERE
    a.orderid = b.orderid
    AND b.orignalprice > 0;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;


  CREATE INDEX ix_t_temp_order_detail_orderid ON t_temp_order_detail (orderid);


  #创建结算明细内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail
  (
    orderid VARCHAR(50),
    payway INT,
    payamount DOUBLE(13, 2),
    couponNum INT,
    bankcardno VARCHAR(50),
    coupondetailid VARCHAR(50),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生产临时结算明细表数据
  INSERT INTO t_temp_settlement_detail
  SELECT b.orderid
       , b.payway
       , b.payamount
       , b.couponNum
       , b.bankcardno
       , b.coupondetailid
       , a.begintime
  FROM
    t_temp_order a, t_settlement_detail b
  WHERE
    a.orderid = b.orderid
    AND b.payamount != 0;
  #创建查询索引


  #创建实收明细内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_paidinamount;
  CREATE TEMPORARY TABLE t_temp_settlement_paidinamount
  (
    orderid VARCHAR(50),
    payamount DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_settlement_paidinamount
  SELECT orderid
       , ifnull(sum(payamount), 0)
  FROM
    t_temp_settlement_detail
  WHERE
    payamount > 0
    AND payway IN (0, 1, 5, 8, 13, 17, 18)  -- SHANGWENCHAO 2015/12/21 23:28:59 增加结算方式13
  GROUP BY
    orderid;
  CREATE INDEX ix_t_temp_settlement_paidinamount_orderid ON t_temp_settlement_paidinamount (orderid);

  #创建会员消费内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
  CREATE TEMPORARY TABLE t_temp_order_member
  (
    orderid VARCHAR(50),
    Inflated DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生成临时会员结算数据  
  INSERT INTO t_temp_order_member
  SELECT b.orderid
       , b.Inflated
  FROM
    t_temp_order a, t_order_member b
  WHERE
    a.orderid = b.orderid;
  CREATE INDEX ix_t_temp_order_member_orderid ON t_temp_order_member (orderid);


  #创建优惠活动内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_preferential;
  CREATE TEMPORARY TABLE t_temp_preferential
  (
    pid VARCHAR(50),
    pname VARCHAR(128),
    ptype CHAR(4),
    ptypename VARCHAR(32)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #生成正常的优惠券数据，包括将其他优惠中的具体原因和合作单位也看成单独的优惠
  INSERT INTO t_temp_preferential
  SELECT a.id
       , (
         CASE
         WHEN a.preferential = a.id THEN
           b.name
         ELSE
           ifnull(ifnull(a.free_reason, a.company_name), b.name)
         END) AS name
       , CASE
         WHEN b.type = '06' THEN
           b.sub_type
         ELSE
           b.type
         END
       , CASE
         WHEN b.type = '06' THEN
           b.sub_type_name
         ELSE
           b.type_name
         END
  FROM
    t_p_preferential_detail a, t_p_preferential_activity b
  WHERE
    a.preferential = b.id;

  ##############################################生成新的结算明细表####################################
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_new;
  CREATE TEMPORARY TABLE t_temp_settlement_new
  (
    orderid VARCHAR(50),
    payway INT, #结算方式
    payamount DOUBLE(13, 2), #结算金额
    couponNum INT, #使用数量
    pname VARCHAR(128), #活动名称
    ptype CHAR(4), #活动分类
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_sub;
  CREATE TEMPORARY TABLE t_temp_settlement_sub
  (
    orderid VARCHAR(50),
    couponNum INT, #使用数量
    pname VARCHAR(128) #活动名称
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;


  #生成挂账和优免数据（不包含金总挂账数据）
  INSERT INTO t_temp_settlement_new
  SELECT a.orderid
       , a.payway
       , a.payamount
       , a.couponNum
       , b.pname
       , b.ptype
       , a.begintime
  FROM
    t_temp_settlement_detail a, t_temp_preferential b
  WHERE
    a.payway IN (5, 6)
    AND a.coupondetailid = b.pid;

  INSERT INTO t_temp_settlement_sub
  SELECT orderid
       , couponNum
       , pname
  FROM
    t_temp_settlement_new
  WHERE
    payway = 6;


  #由于使用一张团购券，会产生2条结算明细（1条挂账，1条优免），需要处理成1条，统计团购券的使用数量时，才可能正确
  UPDATE t_temp_settlement_new a, t_temp_settlement_sub b
  SET
    a.couponNum = 0
  WHERE
    a.orderid = b.orderid
    AND a.pname = b.pname
    AND a.couponNum = b.couponNum
    AND a.payway = 5;


  #生成金总挂账优免数据
  --   INSERT INTO t_temp_settlement_new
  --   SELECT a.orderid
  --        , 6
  --        , a.payamount
  --        , 1
  --        , '金总挂账'
  --        , '0601'
  --        , a.begintime
  --   FROM
  --     t_temp_settlement_detail a
  --   WHERE
  --     a.payway = 13;

  #生成雅座优惠券数据
  INSERT INTO t_temp_settlement_new
  SELECT a.orderid
       , 6
       , a.payamount
       , a.couponNum
       , a.bankcardno
       , '99'
       , a.begintime
  FROM
    t_temp_settlement_detail a
  WHERE
    a.payway = 12;

  CREATE INDEX ix_t_temp_settlement_new_begintime ON t_temp_settlement_new (begintime);


  ##########################################根据在界面选择的时间单位，生成新中间临时数据####################################

  #创建中间临时表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_new_sub;
  CREATE TEMPORARY TABLE t_temp_settlement_new_sub
  (
    orderid VARCHAR(50),
    payway INT, #结算方式
    payamount DOUBLE(13, 2), #结算金额
    couponNum INT, #使用数量
    pname VARCHAR(128), #活动名称
    ptype CHAR(4), #活动分类
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
  CREATE TEMPORARY TABLE t_temp_res_detail
  (
    statistictime VARCHAR(20),
    pname VARCHAR(50),
    ptype CHAR(4),
    pcount INT UNSIGNED,
    pamount DOUBLE(13, 2),
    pshouldamount DOUBLE(13, 2),
    ppaidinamount DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #生成应收表
  DROP TEMPORARY TABLE IF EXISTS t_temp_shouldamount;
  CREATE TEMPORARY TABLE t_temp_shouldamount
  (
    statistictime VARCHAR(20),
    pname VARCHAR(50),
    shouldamount DOUBLE(13, 2) #应收
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  DROP TEMPORARY TABLE IF EXISTS t_temp_orderid;
  CREATE TEMPORARY TABLE t_temp_orderid
  (
    orderid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  #循环计算所需的数据
  WHILE v_loop_num > 0
  DO

    #清空所有的中间临时小表
    TRUNCATE t_temp_settlement_new_sub;

    #把t_temp_settlement_new拆分成一个个字表，加快循环速度
    INSERT INTO t_temp_settlement_new_sub
    SELECT *
    FROM
      t_temp_settlement_new
    WHERE
      begintime BETWEEN v_date_start AND v_date_interval;


    BEGIN
      DECLARE cur_pname CURSOR FOR SELECT DISTINCT pname
                                   FROM
                                     t_temp_settlement_new_sub;

      SET v_fetch_done = FALSE;
      OPEN cur_pname;

    lable_fetch_loop:
      LOOP
        FETCH cur_pname INTO v_pname;
        IF v_fetch_done THEN
          LEAVE lable_fetch_loop;
        END IF;

        SELECT max(ptype)
             , ifnull(sum(couponNum), 0)
             , ifnull(sum(payamount), 0)
        INTO
          v_ptype, v_pcount, v_pamount
        FROM
          t_temp_settlement_new_sub
        WHERE
          pname = v_pname;

        TRUNCATE t_temp_orderid;
        INSERT INTO t_temp_orderid
        SELECT DISTINCT orderid
        FROM
          t_temp_settlement_new_sub
        WHERE
          pname = v_pname;

        #计算应收
        SELECT ifnull(sum(a.orignalprice * a.dishnum), 0)
        INTO
          v_shouldamount
        FROM
          t_temp_order_detail a, t_temp_orderid b
        WHERE
          a.orderid = b.orderid;


        #计算实收（含虚增）
        SELECT ifnull(sum(payamount), 0)
        INTO
          v_paidinacount
        FROM
          t_temp_settlement_paidinamount a, t_temp_orderid b
        WHERE
          a.orderid = b.orderid;


        #计算虚增
        SELECT ifnull(sum(Inflated), 0)
        INTO
          v_inflated
        FROM
          t_temp_order_member a, t_temp_orderid b
        WHERE
          a.orderid = b.orderid;

        INSERT INTO t_temp_res_detail VALUE (v_statistictime, v_pname, v_ptype, v_pcount, v_pamount, v_shouldamount, v_paidinacount - v_inflated);

      END LOOP;

      #最后关闭游标.
      CLOSE cur_pname;
    END;

    IF pi_xslx = 0 THEN
      SET v_date_start = date_add(v_date_start, INTERVAL 1 DAY);
      SET v_date_interval = date_add(v_date_interval, INTERVAL 1 DAY);
      SET v_statistictime = date_format(v_date_start, '%Y-%m-%d');
    ELSE
      SET v_date_start = date_add(v_date_start, INTERVAL 1 MONTH);
      SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 MONTH), INTERVAL 1 SECOND);
      SET v_statistictime = date_format(v_date_start, '%Y-%m');
    END IF;

    SET v_loop_num = v_loop_num - 1;
  END WHILE;
  COMMIT;

  #创建结果内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    showtype TINYINT,
    pname VARCHAR(50),
    total_num DOUBLE(13, 2),
    detail_num VARCHAR(1000),
    PRIMARY KEY (id)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;


  #按活动名称来统计
  IF pi_tjx = 0 THEN

    #发生笔数
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 0
         , pname
         , sum(pcount)
    FROM
      t_temp_res_detail
    GROUP BY
      pname;

    #发生金额
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 1
         , pname
         , sum(pamount)
    FROM
      t_temp_res_detail
    GROUP BY
      pname;

    #拉动应收
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 2
         , pname
         , sum(pshouldamount)
    FROM
      t_temp_res_detail
    GROUP BY
      pname;

    #拉动实收
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 3
         , pname
         , sum(ppaidinamount)
    FROM
      t_temp_res_detail
    GROUP BY
      pname;
  #按活动类型来统计
  ELSE
    #发生笔数
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 0
         , ptype
         , sum(pcount)
    FROM
      t_temp_res_detail
    GROUP BY
      ptype;

    #发生金额
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 1
         , ptype
         , sum(pamount)
    FROM
      t_temp_res_detail
    GROUP BY
      ptype;

    #拉动应收
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 2
         , ptype
         , sum(pshouldamount)
    FROM
      t_temp_res_detail
    GROUP BY
      ptype;

    #拉动实收
    INSERT INTO t_temp_res (showtype, pname, total_num)
    SELECT 3
         , ptype
         , sum(ppaidinamount)
    FROM
      t_temp_res_detail
    GROUP BY
      ptype;
  END IF;

  #获取自增长字段的偏移量和自增量，以及自增字段的最大值
  SET @offset = @@auto_increment_offset;
  SET @increment = @@auto_increment_increment;
  SELECT ifnull(max(id), 0)
  INTO
    @maxid
  FROM
    t_temp_res;

#组装每天（每月）拆分的值
  loop_lable1:
  LOOP
    #循环结束标识
    IF @offset > @maxid THEN
      LEAVE loop_lable1;
    END IF;

    #通过ID来遍历每一条数据
    SELECT showtype
         , pname
    INTO
      v_showtype, v_pname
    FROM
      t_temp_res
    WHERE
      id = @offset;

    IF pi_tjx = 0 THEN
      IF v_showtype = 0 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', pcount) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            pname = v_pname
          ORDER BY
            statistictime ASC) t;

      ELSEIF v_showtype = 1 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', pamount) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            pname = v_pname
          ORDER BY
            statistictime ASC) t;

      ELSEIF v_showtype = 2 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', pshouldamount) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            pname = v_pname
          ORDER BY
            statistictime ASC) t;

      ELSEIF v_showtype = 3 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', ppaidinamount) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            pname = v_pname
          ORDER BY
            statistictime ASC) t;

      ELSE
        LEAVE loop_lable1;
      END IF;
    ELSE
      IF v_showtype = 0 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', sum(pcount)) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            ptype = v_pname
          GROUP BY
            statistictime
          ORDER BY
            statistictime ASC) t;

      ELSEIF v_showtype = 1 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', sum(pamount)) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            ptype = v_pname
          GROUP BY
            statistictime
          ORDER BY
            statistictime ASC) t;

      ELSEIF v_showtype = 2 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', sum(pshouldamount)) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            ptype = v_pname
          GROUP BY
            statistictime
          ORDER BY
            statistictime ASC) t;

      ELSEIF v_showtype = 3 THEN
        SELECT group_concat(t.value_detail SEPARATOR '|')
        INTO
          v_value_detail
        FROM
          (
          SELECT concat(statistictime, ',', sum(ppaidinamount)) AS value_detail
          FROM
            t_temp_res_detail
          WHERE
            ptype = v_pname
          GROUP BY
            statistictime
          ORDER BY
            statistictime ASC) t;

      ELSE
        LEAVE loop_lable1;
      END IF;
    END IF;



    #设置拆分值
    UPDATE t_temp_res
    SET
      detail_num = v_value_detail
    WHERE
      id = @offset;

    #设置下一个id
    SET @offset = @offset + @increment;
  END LOOP;

  #如果统计的活动类型，还需要将活动类型编码转化为活动类型名称
  IF pi_tjx = 1 THEN
    SELECT a.showtype
         , t.ptypename
         , a.total_num
         , a.detail_num
    FROM
      t_temp_res a, (SELECT DISTINCT b.ptype
                                   , b.ptypename
                     FROM
                       t_temp_preferential b) t
    WHERE
      a.pname = t.ptype;
  #返回结果
  ELSE
    SELECT showtype
         , pname
         , total_num
         , detail_num
    FROM
      t_temp_res;
  END IF;

#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_paidinamount;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_preferential;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_new;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_sub;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_new_sub;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_shouldamount;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_orderid;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;


END
$$

DROP PROCEDURE IF EXISTS p_report_yyfx_yysjtj$$
CREATE PROCEDURE p_report_yyfx_yysjtj(IN  pi_branchid INT(11), -- 分店id
                                      IN  pi_xslx     SMALLINT, -- 显示类别 0:日  1:月  2:年
                                      IN  pi_ksrq     DATETIME, -- 开始日期
                                      IN  pi_jsrq     DATETIME, -- 结束日期
                                      OUT po_errmsg   VARCHAR(100)
                                      -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '营业分析_营业数据统计'
label_main:
BEGIN
  -- 返回字段说明如下：
  -- 时间，应收总额，实收总额， 折扣总额
  --
  -- 返回数据举例（多行数据）：
  -- 2015-05  3636.00  3630.00  6.00
  -- 2015-06  4636.00  4630.00  6.00

  DECLARE v_date_start    DATETIME;
  DECLARE v_date_end      DATETIME;
  DECLARE v_date_interval DATETIME; #时间间隔
  DECLARE v_loop_num      INT DEFAULT 0; #根据开始结束时间和显示类型，来设置循环次数
  DECLARE v_statistictime VARCHAR(15); #统计日期
  DECLARE v_shouldamount  DOUBLE(13, 2); #应收
  DECLARE v_paidinamount  DOUBLE(13, 2); #实收(含虚增)
  DECLARE v_inflated      DOUBLE(13, 2); #虚增

  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;


  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  #设置临时内存表
  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;


  #设置循环次数,处理开始结算时间
  IF pi_xslx = 0 THEN
    SET v_statistictime = date_format(pi_ksrq, '%Y-%m-%d');
    SET v_date_start = str_to_date(concat(v_statistictime, '00:00:00'), '%Y-%m-%d %H:%i:%s');
    SET v_date_end = str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');
    SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 DAY), INTERVAL 1 SECOND);
    SET v_loop_num = timestampdiff(DAY, v_date_start, v_date_end) + 1;
  ELSEIF pi_xslx = 1 THEN
    SET v_statistictime = date_format(pi_ksrq, '%Y-%m');
    SET v_date_start = str_to_date(concat(v_statistictime, '-01 00:00:00'), '%Y-%m-%d %H:%i:%s');
    SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 MONTH), INTERVAL 1 SECOND);
    SET v_date_end = date_sub(date_add(str_to_date(concat(date_format(pi_jsrq, '%Y-%m'), '-01 00:00:00'), '%Y-%m-%d %H:%i:%s'), INTERVAL 1 MONTH), INTERVAL 1 SECOND);
    SET v_loop_num = timestampdiff(MONTH, v_date_start, v_date_end) + 1;
  ELSE
    SELECT NULL;
    LEAVE label_main;
  END IF;

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_order
  SELECT orderid
       , begintime
  FROM
    t_order USE INDEX (IX_t_order_begintime)
  WHERE
    branchid = pi_branchid
    AND begintime BETWEEN v_date_start AND v_date_end # 需要创建索引IX_t_order_begintime  
    AND orderstatus = 3;


  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);
  CREATE INDEX ix_t_temp_order_begintime ON t_temp_order (begintime);

  #创建订单详情临时内存表（方便计算应收）
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    begintime DATETIME,
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  # 向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT b.orderid
       , b.dishnum
       , b.orignalprice
       , b.begintime
       , b.childdishtype
       , b.primarykey
       , b.superkey
  FROM
    t_temp_order a, t_order_detail b
  WHERE
    a.orderid = b.orderid
    AND orignalprice > 0;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;

  #为订单详情表创建索引
  CREATE INDEX ix_t_temp_order_detail_begintime ON t_temp_order_detail (begintime);

  #创建结算明细内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail
  (
    orderid VARCHAR(50),
    payway INT,
    payamount DOUBLE(13, 2),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生产临时结算明细表数据
  INSERT INTO t_temp_settlement_detail
  SELECT b.orderid
       , b.payway
       , b.payamount
       , a.begintime
  FROM
    t_temp_order a, t_settlement_detail b
  WHERE
    a.orderid = b.orderid
    AND b.payamount > 0
    AND b.payway IN (0, 1, 5, 8, 13, 17, 18);  -- SHANGWENCHAO 2015/12/21 23:28:59 增加结算方式13
  CREATE INDEX ix_t_temp_settlement_detail_begintime ON t_temp_settlement_detail (begintime);

  #创建会员消费内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
  CREATE TEMPORARY TABLE t_temp_order_member
  (
    orderid VARCHAR(50),
    Inflated DOUBLE(13, 2),
    begintime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生成临时会员结算数据  
  INSERT INTO t_temp_order_member
  SELECT b.orderid
       , b.Inflated
       , a.begintime
  FROM
    t_temp_order a, t_order_member b
  WHERE
    a.orderid = b.orderid;
  CREATE INDEX ix_t_temp_order_member_begintime ON t_temp_order_member (begintime);

  #创建结果内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    statistictime VARCHAR(15), #统计日期
    shouldamount DOUBLE(13, 2), #应收
    paidinamount DOUBLE(13, 2), #实收
    discountamount DOUBLE(13, 2) #折扣
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #循环计算所需的数据
  WHILE v_loop_num > 0
  DO

    #计算应收
    SELECT ifnull(sum(orignalprice * dishnum), 0)
    INTO
      v_shouldamount
    FROM
      t_temp_order_detail
    WHERE
      begintime BETWEEN v_date_start AND v_date_interval;

    #计算实收（含虚增）
    SELECT ifnull(sum(payamount), 0)
    INTO
      v_paidinamount
    FROM
      t_temp_settlement_detail
    WHERE
      begintime BETWEEN v_date_start AND v_date_interval;

    #计算虚增
    SELECT ifnull(sum(Inflated), 0)
    INTO
      v_inflated
    FROM
      t_temp_order_member
    WHERE
      begintime BETWEEN v_date_start AND v_date_interval;

    INSERT INTO t_temp_res VALUES (v_statistictime, v_shouldamount, v_paidinamount - v_inflated, v_shouldamount - v_paidinamount + v_inflated);

    IF pi_xslx = 0 THEN
      SET v_date_start = date_add(v_date_start, INTERVAL 1 DAY);
      SET v_date_interval = date_add(v_date_interval, INTERVAL 1 DAY);
      SET v_statistictime = date_format(v_date_start, '%Y-%m-%d');
    ELSE
      SET v_date_start = date_add(v_date_start, INTERVAL 1 MONTH);
      SET v_date_interval = date_sub(date_add(v_date_start, INTERVAL 1 MONTH), INTERVAL 1 SECOND);
      SET v_statistictime = date_format(v_date_start, '%Y-%m');
    END IF;

    SET v_loop_num = v_loop_num - 1;
  END WHILE;
  COMMIT;

  #返回结果集
  SELECT *
  FROM
    t_temp_res;

#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_keys;

END
$$

DROP PROCEDURE IF EXISTS p_report_yysjmxb$$

CREATE PROCEDURE p_report_yysjmxb(IN  pi_branchid INT(11), -- 分店id
                                  IN  pi_sb       SMALLINT, -- 市别，0:午市；1:晚市；-1:全天
                                  IN  pi_ksrq     DATETIME, -- 开始日期，
                                  IN  pi_jsrq     DATETIME, -- 结束日期
                                  OUT po_errmsg   VARCHAR(100)
                                  -- 错误信息
)
SQL SECURITY INVOKER
COMMENT '营业数据明细表'
label_main:
BEGIN
  -- 返回字段说明如下(23个字段)：
  -- 应收总额，实收总额，折扣总额，现金，挂账，刷卡，会员储值消费净值，优免，会员积分消费，会员券消费，折扣优惠，抹零，赠送金额，会员储值消费虚增，桌数，桌均消费，结算人数，应收人均，实收人均，上座率，翻台率，平均消费时间，合计
  --
  -- 返回数据举例（只返回一条数据）：
  -- 3895.00 3636.00 259.00 3895 0 0 0 14.50 0 0 0 0.5 0.5 0.5 9 432.78 28 129.86	139.11 0.41	0.70 31 0.00 0.00	0.00 0.00	0.00


  DECLARE v_date_start            DATETIME;
  DECLARE v_date_end              DATETIME;
  DECLARE v_paidinamount          DOUBLE(13, 2) DEFAULT 0; #实收

  #以下为实收明细统计项
  DECLARE v_pa_cash               DOUBLE(13, 2) DEFAULT 0; #实收（现金）
  DECLARE v_pa_credit             DOUBLE(13, 2) DEFAULT 0; #实收（挂账）
  DECLARE v_pa_card               DOUBLE(13, 2) DEFAULT 0; #实收（刷卡——刷他行卡）
  DECLARE v_pa_icbc_card          DOUBLE(13, 2) DEFAULT 0; #实收（刷卡——刷工行卡）
  DECLARE v_pa_paidinamount       DOUBLE(13, 2) DEFAULT 0; #会员储值消费（含虚增）
  DECLARE v_pa_weixin             DOUBLE(13, 2) DEFAULT 0; #实收（微信）
  DECLARE v_pa_zhifubao           DOUBLE(13, 2) DEFAULT 0; #实收（支付宝）

  #以下为折扣明细统计项
  DECLARE v_da_free               DOUBLE(13, 2) DEFAULT 0; #折扣(优免）
  DECLARE v_da_integralconsum     DOUBLE(13, 2) DEFAULT 0; #折扣(会员积分消费）
  DECLARE v_da_meberTicket        DOUBLE(13, 2) DEFAULT 0; #折扣(会员券）
  DECLARE v_da_discount           DOUBLE(13, 2) DEFAULT 0; #折扣(折扣额）
  DECLARE v_da_fraction           DOUBLE(13, 2) DEFAULT 0; #折扣(抹零）
  DECLARE v_da_roundoff           DOUBLE(13, 2) DEFAULT 0; #折扣(抹零）
  DECLARE v_da_give               DOUBLE(13, 2) DEFAULT 0; #折扣(赠送）
  DECLARE v_da_mebervalueadd      DOUBLE(13, 2) DEFAULT 0; #折扣(虚增）

  #以下为营业数据统计项(堂吃)
  DECLARE v_sa_ordercount         INT DEFAULT 0; #营业数据统计(桌数）
  DECLARE v_sa_tableconsumption   DOUBLE(13, 2) DEFAULT 0; #营业数据统计(桌均消费）  
  DECLARE v_sa_settlementnum      INT DEFAULT 0; #营业数据统计(总人数）
  DECLARE v_sa_shouldamount       DOUBLE(13, 2) DEFAULT 0; #营业数据统计(应收）
  DECLARE v_sa_shouldaverage      DOUBLE(13, 2) DEFAULT 0; #营业数据统计(应收人均）
  DECLARE v_sa_paidinaverage      DOUBLE(13, 2) DEFAULT 0; #营业数据统计(实收人均）
  DECLARE v_sa_attendance         DOUBLE(13, 2) DEFAULT 0; #营业数据统计(上座率）
  DECLARE v_sa_overtaiwan         DOUBLE(13, 2) DEFAULT 0; #营业数据统计(翻台率）
  DECLARE v_sa_avgconsumtime      DOUBLE(13, 2) DEFAULT 0; #营业数据统计(平均消费时间）

  #以下为会员数据统计项目
  DECLARE v_ma_total              DOUBLE(13, 2) DEFAULT 0; #会员券消费额

  #以下为外卖数据统计项
  DECLARE v_oa_shouldamount       DOUBLE(13, 2) DEFAULT 0; #外卖（应收）
  DECLARE v_oa_paidinamount       DOUBLE(13, 2) DEFAULT 0; #外卖（实收）
  DECLARE v_oa_mebervalueadd      DOUBLE(13, 2) DEFAULT 0; #外卖（虚增）
  DECLARE v_oa_ordercount         INT(11) DEFAULT 0; #外卖（单数）
  DECLARE v_oa_avgprice           DOUBLE(13, 2) DEFAULT 0; #外卖（单均）

  #其他数据
  DECLARE v_other_tablecount      INT DEFAULT 0; #餐台总的餐台数量
  DECLARE v_other_tableperson     INT DEFAULT 0; #餐台所有餐台的总的座位数
  DECLARE v_other_vipordercount   INT DEFAULT 0; #会员消费笔数
  DECLARE v_other_viporderpercent DOUBLE(13, 2) DEFAULT 0; #会员消费占比



  -- 异常处理模块，出现异常返回null
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SELECT NULL;
    GET DIAGNOSTICS CONDITION 1 po_errmsg = MESSAGE_TEXT;
  END;

  IF pi_branchid IS NULL THEN
    SELECT NULL;
    SET po_errmsg = '分店ID输入不能为空';
    LEAVE label_main;
  END IF;


  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;


  #处理开始结束时间
  SET v_date_start = pi_ksrq; #str_to_date(concat(date_format(pi_ksrq, '%Y-%m-%d'), '00:00:00'), '%Y-%m-%d %H:%i:%s');
  SET v_date_end = pi_jsrq; #str_to_date(concat(date_format(pi_jsrq, '%Y-%m-%d'), '23:59:59'), '%Y-%m-%d %H:%i:%s');

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50),
    womanNum TINYINT UNSIGNED,
    childNum TINYINT UNSIGNED,
    mannum TINYINT UNSIGNED,
    ordertype TINYINT,
    begintime DATETIME,
    endtime DATETIME
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_sb > -1 THEN
    INSERT INTO t_temp_order
    SELECT orderid
         , womanNum
         , childNum
         , mannum
         , ordertype
         , begintime
         , endtime
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND shiftid = pi_sb
      AND orderstatus = 3;
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
         , womanNum
         , childNum
         , mannum
         , ordertype
         , begintime
         , endtime
    FROM
      t_order USE INDEX (IX_t_order_begintime)
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN v_date_start AND v_date_end -- 需要创建索引IX_t_order_begintime  
      AND orderstatus = 3;
  END IF;
  #为订单内存表创建索引
  CREATE UNIQUE INDEX ix_t_temp_order_orderid ON t_temp_order (orderid);


  #创建订单详情临时内存表（方便计算应收）
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    ordertype TINYINT,
    pricetype CHAR(1),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  # 向临时订单详情内存表中放值
  INSERT INTO t_temp_order_detail
  SELECT b.orderid
       , b.dishnum
       , b.orignalprice
       , a.ordertype
       , b.pricetype
       , b.childdishtype
       , b.primarykey
       , b.superkey
  FROM
    t_temp_order a, t_order_detail b
  WHERE
    a.orderid = b.orderid
    AND orignalprice > 0;

  # 删除套餐明细
  DROP TEMPORARY TABLE IF EXISTS t_temp_keys;
  CREATE TEMPORARY TABLE t_temp_keys
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  INSERT INTO t_temp_keys
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    childdishtype = 2;

  DELETE
  FROM
    t_temp_order_detail
  USING
    t_temp_order_detail, t_temp_keys
  WHERE
    t_temp_order_detail.superkey = t_temp_keys.primarykey
    AND t_temp_order_detail.primarykey != t_temp_keys.primarykey;

  #创建结算明细内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail
  (
    orderid VARCHAR(50),
    payway INT,
    payamount DOUBLE(13, 2),
    couponid VARCHAR(50),
    ordertype TINYINT,
    isviporder TINYINT,
    membercardno VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生产临时结算明细表数据
  INSERT INTO t_temp_settlement_detail
  SELECT b.orderid
       , b.payway
       , b.payamount
       , b.couponid
       , a.ordertype
       , CASE
         WHEN b.payway = 8 AND char_length(b.membercardno) > 1 THEN
           1
         ELSE
           0
         END
       , b.membercardno
  FROM
    t_temp_order a, t_settlement_detail b
  WHERE
    a.orderid = b.orderid;


  #除会员验证的那条数据外，删除其它无效数据
  DELETE
  FROM
    t_temp_settlement_detail
  WHERE
    isviporder = 0
    AND payamount = 0;

  #创建会员消费内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
  CREATE TEMPORARY TABLE t_temp_order_member
  (
    orderid VARCHAR(50),
    Inflated DOUBLE(13, 2),
    netvalue DOUBLE(13, 2),
    ordertype TINYINT
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #生成临时会员结算数据  
  INSERT INTO t_temp_order_member
  SELECT b.orderid
       , b.Inflated
       , b.netvalue
       , a.ordertype
  FROM
    t_temp_order a, t_order_member b
  WHERE
    a.orderid = b.orderid;


  ####################开始计算数据##################
  #设置订单数和人数
  SELECT sum(
         CASE ordertype
         WHEN 0 THEN
           1
         ELSE
           0
         END) #堂吃的订单数量
         , ifnull(sum(
         CASE ordertype
         WHEN 0 THEN
           mannum + womanNum + childNum
         ELSE
           0
         END), 0) #堂吃的就餐总人数
         , sum(
         CASE ordertype
         WHEN 0 THEN
           0
         ELSE
           1
         END) #外卖的订单数量
  INTO
    v_sa_ordercount, v_sa_settlementnum, v_oa_ordercount
  FROM
    t_temp_order;


  #计算应收总额
  SELECT ifnull(sum(
         CASE ordertype
         WHEN 0 THEN
           orignalprice * dishnum
         ELSE
           0
         END), 0) #堂吃应收
         , ifnull(sum(
         CASE ordertype
         WHEN 0 THEN
           0
         ELSE
           orignalprice * dishnum
         END), 0) #外卖应收
         , ifnull(sum(
         CASE pricetype
         WHEN '1' THEN
           orignalprice * dishnum
         ELSE
           0
         END), 0) #赠送金额
  INTO
    v_sa_shouldamount, v_oa_shouldamount, v_da_give
  FROM
    t_temp_order_detail;

  #计算虚增，储值消费净值
  SELECT ifnull(sum(Inflated), 0)
       , ifnull(sum(
         CASE ordertype
         WHEN 0 THEN
           0
         ELSE
           Inflated
         END), 0)
  INTO
    v_da_mebervalueadd, v_oa_mebervalueadd
  FROM
    t_temp_order_member;

  #计算外卖订单的实收金额（含虚增）
  SELECT ifnull(sum(payamount), 0)
  INTO
    v_oa_paidinamount
  FROM
    t_temp_settlement_detail
  WHERE
    payway IN (0, 1, 5, 8, 13, 17, 18)  -- SHANGWENCHAO 2015/12/21 23:28:59 增加结算方式13
    AND ordertype > 0;

  #设置实收（外卖） = 外卖实收- 外卖虚增
  SET v_oa_paidinamount = v_oa_paidinamount - v_oa_mebervalueadd;

  #计算每种结算方式的结算金额
  SELECT ifnull(sum(
         CASE
         WHEN payway = 0 THEN #现金
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway = 1 and membercardno='0' and payamount<>0 THEN #刷它行卡
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway = 1 and membercardno='1' and payamount<>0 THEN #刷工行卡
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway in(5,13) AND payamount > 0 THEN #挂账 --SHANGWENCHAO 2015/12/21 23:28:59 13也是挂账
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway = 8 THEN #会员卡消费
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway = 11 THEN #会员积分消费
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway = 12 THEN #会员券消费
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway = 7 THEN #抹零
           payamount
         ELSE
           0
         END), 0)
       , 0 - ifnull(sum(
         CASE
         WHEN payway = 20 THEN #四舍五入调整
           payamount
         ELSE
           0
         END), 0)
       , sum(isviporder) #会员订单数量
       , ifnull(sum(
         CASE
         WHEN payway = 17 THEN #微信支付
           payamount
         ELSE
           0
         END), 0)
       , ifnull(sum(
         CASE
         WHEN payway = 18 THEN #支付宝支付
           payamount
         ELSE
           0
         END), 0)
  INTO
    v_pa_cash, v_pa_card, v_pa_icbc_card, v_pa_credit, v_pa_paidinamount, v_da_integralconsum, v_da_meberTicket, v_da_fraction, v_da_roundoff, v_other_vipordercount, v_pa_weixin, v_pa_zhifubao
  FROM
    t_temp_settlement_detail;

  #设置实收（全部） = 现金 + 挂账 + 刷他行卡 + 会员储值消费 - 会员储值消费虚增 + 刷工行卡 + 微信支付 + 支付宝支付
  SET v_paidinamount = v_pa_cash + v_pa_credit + v_pa_card + v_pa_paidinamount - v_da_mebervalueadd + v_pa_icbc_card + v_pa_weixin + v_pa_zhifubao;

  #设置折扣额
  SELECT ifnull(sum(a.payamount), 0)
  INTO
    v_da_discount
  FROM
    t_temp_settlement_detail a, t_p_preferential_activity b
  WHERE
    a.couponid = b.id
    AND b.type = '02';

  #设置赠送金额（目前暂时默认为0）
  #SET v_da_give = 0;

  #设置优免金额 =堂吃应收+外卖应收 - 实收 - 四舍五入调整 - 会员积分消费 - 会员券消费 - 折扣优惠 - 抹零 - 赠送 - 虚增
  SET v_da_free = v_sa_shouldamount + v_oa_shouldamount - v_paidinamount - v_da_roundoff - v_da_integralconsum - v_da_meberTicket - v_da_discount - v_da_fraction - v_da_give - v_da_mebervalueadd;

  #获取餐厅总的餐台数
  SELECT count(1)
       , sum(a.personNum)
  INTO
    v_other_tablecount, v_other_tableperson
  FROM
    t_table a, t_tablearea b
  WHERE
    a.areaid = b.areaid
    AND b.branchid = pi_branchid
    AND a.status IN (0, 1);


  IF v_sa_ordercount > 0 THEN
    #计算上座率  总人数/总天数=平均每天总人数；平均每天总人数/标准座位数=上座率
    SET v_sa_attendance = v_sa_settlementnum / (timestampdiff(DAY, v_date_start, v_date_end) + 1) / v_other_tableperson * 100;

    #计算翻台率  总用餐桌数/总天数=平均每天总桌数；平均每天总桌数/标准桌数=翻台率
    SET v_sa_overtaiwan = v_sa_ordercount / (timestampdiff(DAY, v_date_start, v_date_end) + 1) / v_other_tablecount * 100;

    #计算桌均消费 = （实收总额 - 外卖实收） / 总桌数
    SET v_sa_tableconsumption = (v_paidinamount - v_oa_paidinamount) / v_sa_ordercount;

    #应收人均 = 应收总额 / 总就餐人数
    SET v_sa_shouldaverage = v_sa_shouldamount / v_sa_settlementnum;

    #实收人均 = （实收总额 - 外卖实收） / 总就餐人数
    SET v_sa_paidinaverage = (v_paidinamount - v_oa_paidinamount) / v_sa_settlementnum; #营业数据统计(实收人均）

    #计算平均就餐时间（分钟）=总时长/总用餐桌数
    SELECT sum(timestampdiff(SECOND, begintime, endtime)) / v_sa_ordercount / 60
    INTO
      v_sa_avgconsumtime
    FROM
      t_temp_order
    WHERE
      ordertype = 0
      AND endtime IS NOT NULL;
  END IF;

  IF v_oa_ordercount > 0 THEN
    #外卖单均 = 外卖应收 / 外卖单数
    SET v_oa_avgprice = v_oa_paidinamount / v_oa_ordercount;
  END IF;

  #会员消费合计 = 会员券消费 + 会员积分消费 + 会员储值消费（包括净值和虚增）
  SET v_ma_total = v_da_meberTicket + v_da_integralconsum + v_pa_paidinamount;

  #设置会员消费占比 = 会员消费笔数 / 订单总数   订单总数 = 堂吃订单数 + 外买订单数
  SET v_other_viporderpercent = v_other_vipordercount / (v_sa_ordercount + v_oa_ordercount) * 100;

  ####################开始处理结果数据##################
  #创建结果内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_res;
  CREATE TEMPORARY TABLE t_temp_res
  (
    shouldamount DOUBLE(13, 2), #应收总额
    paidinamount DOUBLE(13, 2), #实收总额
    discountamount DOUBLE(13, 2), #折扣总额
    cash DOUBLE(13, 2), #实收（现金）
    credit DOUBLE(13, 2), #实收（挂账）
    card DOUBLE(13, 2), #实收（刷他行卡）
    icbccard DOUBLE(13, 2), #实收（刷工行卡）
    weixin DOUBLE(13, 2), #实收（微信）
    zhifubao DOUBLE(13, 2), #实收（支付宝）
    merbervaluenet DOUBLE(13, 2), #实收（会员储值消费净值）
    free DOUBLE(13, 2), #折扣(优免）
    integralconsum DOUBLE(13, 2), #折扣(会员积分消费）
    meberTicket DOUBLE(13, 2), #折扣(会员券）
    discount DOUBLE(13, 2), #折扣(折扣额）
    fraction DOUBLE(13, 2), #折扣(抹零）
    give DOUBLE(13, 2), #折扣(赠送）
    roundoff DOUBLE(13, 2), #折扣(四舍五入调整）
    mebervalueadd DOUBLE(13, 2), #折扣(虚增）
    tablecount DOUBLE(13, 2), #营业数据统计(桌数）
    tableconsumption DOUBLE(13, 2), #营业数据统计(桌均消费）  
    settlementnum DOUBLE(13, 2), #营业数据统计(总人数）
    shouldaverage DOUBLE(13, 2), #营业数据统计(应收人均）
    paidinaverage DOUBLE(13, 2), #营业数据统计(实收人均）
    attendance DOUBLE(13, 2), #营业数据统计(上座率）
    overtaiwan DOUBLE(13, 2), #营业数据统计(翻台率）
    avgconsumtime DOUBLE(13, 2), #营业数据统计(平均消费时间）
    shouldamount_normal DOUBLE(13, 2), #营业数据统计(堂吃应收）
    shouldamount_takeout DOUBLE(13, 2), #外卖统计(应收）
    paidinamount_takeout DOUBLE(13, 2), #外卖统计(实收）
    ordercount_takeout DOUBLE(13, 2), #外卖统计(订单数）
    avgprice_takeout DOUBLE(13, 2), #外卖统计(订单平均价格）
    vipordercount INT(11), #会员消费笔数
    viporderpercent DOUBLE(13, 2), #会员消费占比
    membertotal DOUBLE(13, 2) #会员消费合计
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_res VALUES (v_sa_shouldamount + v_oa_shouldamount, v_paidinamount, v_sa_shouldamount + v_oa_shouldamount - v_paidinamount, v_pa_cash, v_pa_credit, v_pa_card, v_pa_icbc_card, v_pa_weixin, v_pa_zhifubao, v_pa_paidinamount - v_da_mebervalueadd, v_da_free, v_da_integralconsum, v_da_meberTicket, v_da_discount, v_da_fraction, v_da_give, v_da_roundoff, v_da_mebervalueadd, v_sa_ordercount, v_sa_tableconsumption, v_sa_settlementnum, v_sa_shouldaverage, v_sa_paidinaverage, v_sa_attendance, v_sa_overtaiwan, v_sa_avgconsumtime, v_sa_shouldamount, v_oa_shouldamount, v_oa_paidinamount, v_oa_ordercount, v_oa_avgprice, v_other_vipordercount, v_other_viporderpercent, v_ma_total);
  SELECT *
  FROM
    t_temp_res;

#清空内存表
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_order_member;
--   DROP TEMPORARY TABLE IF EXISTS t_temp_res;
END
$$

DELIMITER ;

-- 
-- Enable foreign keys
-- 
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;