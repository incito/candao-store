-- Script was generated by Devart dbForge Studio for MySQL, Version 5.0.50.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 2015/12/2 15:45:41
-- Server version: 5.6.25-log
-- Client version: 4.1

-- 
-- Disable foreign keys
-- 
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

-- 
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8';

DELIMITER $$

--
-- Definition for view v_currmenu
--
DROP VIEW IF EXISTS v_currmenu CASCADE $$
CREATE OR REPLACE SQL SECURITY INVOKER

VIEW v_currmenu
AS
	select tm.menuid AS menuid from ((t_branch_info tbf join t_menu_branch mb) join t_menu tm) where ((tbf.branchid = mb.branchid) and (mb.menuid = tm.menuid) and (tm.status = '1')) order by tm.effecttime desc limit 1 $$

--
-- Definition for view v_order
--
DROP VIEW IF EXISTS v_order CASCADE $$
CREATE OR REPLACE SQL SECURITY INVOKER
VIEW v_order
AS
	select a.tableNo AS tableNo,a.tableid AS tableid,a.orderid AS orderid,c.dishid AS dishid,c.title AS title,b.dishunit AS dishunit,b.dishnum AS dishnum,b.orderprice AS orderprice,b.orderdetailid AS orderdetailid,b.orderseq AS orderseq from ((t_table a join t_order_detail b) join t_dish c) where ((a.orderid = b.orderid) and (b.dishid = c.dishid)) $$

--
-- Definition for view v_revenuepayway
--
CREATE OR REPLACE SQL SECURITY DEFINER
VIEW `v_payway` AS
select `d`.`dictid` AS `dictid`,`d`.`itemid` AS `itemid`,`d`.`itemDesc` AS `itemDesc`,`d`.`itemSort` AS `itemSort`,`d`.`status` AS `status`,`d`.`type` AS `type`,`d`.`typename` AS `typename`,`d`.`charges_status` AS `chargeStatus`,`ps`.`status` AS `isshow`,`ps`.`sort` AS `self_sort` from (`t_dictionary` `d` left join `t_payway_set` `ps` on((`d`.`itemid` = `ps`.`item_id`))) where (`d`.`type` = 'PAYWAY')$$

CREATE OR REPLACE SQL SECURITY INVOKER
VIEW `v_revenuepayway`
AS
select `v_payway`.`dictid` AS `dictid`,`v_payway`.`itemid` AS `itemid`,`v_payway`.`itemDesc` AS `itemDesc`,`v_payway`.`itemSort` AS `itemSort`,`v_payway`.`status` AS `status`,`v_payway`.`type` AS `type`,`v_payway`.`typename` AS `typename`,`v_payway`.`chargeStatus` AS `chargeStatus`,`v_payway`.`isshow` AS `isshow`,`v_payway`.`self_sort` AS `self_sort` from `v_payway` where (`v_payway`.`chargeStatus` = 1)$$

--
-- Definition for view v_t_p_preferential_activity
--
DROP VIEW IF EXISTS v_t_p_preferential_activity CASCADE $$
CREATE OR REPLACE SQL SECURITY INVOKER
VIEW v_t_p_preferential_activity
AS
	select (case when (a.preferential = a.id) then b.name else ifnull(ifnull(a.free_reason,a.company_name),b.name) end) AS id,(case when (a.preferential = a.id) then b.name else ifnull(ifnull(a.free_reason,a.company_name),b.name) end) AS name,b.type AS type,b.type_name AS type_name,b.sub_type AS sub_type,b.sub_type_name AS sub_type_name,a.preferential AS preferential from (t_p_preferential_detail a join t_p_preferential_activity b on((a.preferential = b.id))) union select distinct t_settlement_detail.bankcardno AS id,t_settlement_detail.bankcardno AS name,'12' AS type,'会员' AS type_name,'' AS sub_type,'' AS sub_type_name,t_settlement_detail.bankcardno AS preferential from t_settlement_detail where (t_settlement_detail.payway = '12')$$




DROP PROCEDURE IF EXISTS p_cal_dishset_price$$
CREATE PROCEDURE p_cal_dishset_price()
SQL SECURITY INVOKER
COMMENT '计算套餐的实收金额'
BEGIN
  DECLARE v_fetch_done           NUMERIC DEFAULT 0;
  DECLARE v_primarykey           VARCHAR(50);
  DECLARE v_dishset_debitamount  DECIMAL(10, 2);
  DECLARE v_dishset_orignalprice DECIMAL(10, 2);

  DECLARE cur_dish_set CURSOR FOR
  SELECT *
  FROM
    t_temp_dishset tod;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_fetch_done = 1;


  #如果套餐没有使用优惠，则将套餐的价格设置成订单价格
  UPDATE t_temp_order_detail
  SET
    debitamount = dishnum * orderprice
  WHERE
    dishtype = '2'
    AND primarykey = superkey
    AND debitamount IS NULL;

  #找出所有套餐的外壳
  DROP TEMPORARY TABLE IF EXISTS t_temp_dishset;
  CREATE TEMPORARY TABLE t_temp_dishset
  (
    primarykey VARCHAR(50),
    debitamount DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dishset
  SELECT primarykey
       , debitamount
  FROM
    t_temp_order_detail tod
  WHERE
    dishtype = '2'
    AND primarykey = superkey;

  OPEN cur_dish_set;

loop_lable:
  LOOP
    FETCH cur_dish_set INTO v_primarykey, v_dishset_debitamount;

    #获取套餐总的原价
    SELECT sum(ifnull(dishnum * orignalprice, 0))
    INTO
      v_dishset_orignalprice
    FROM
      t_temp_order_detail
    WHERE
      superkey = v_primarykey
      AND primarykey != v_primarykey;

    #循环结束标识
    IF v_fetch_done THEN
      LEAVE loop_lable;
    END IF;

    IF v_dishset_orignalprice * v_dishset_debitamount IS NOT NULL AND v_dishset_orignalprice * v_dishset_debitamount != 0 THEN
      UPDATE t_temp_order_detail
      SET
        debitamount = dishnum * orignalprice / v_dishset_orignalprice * v_dishset_debitamount
      WHERE
        superkey = v_primarykey
        AND primarykey != v_primarykey;
    END IF;
  END LOOP;
  CLOSE cur_dish_set;
END
$$

DROP PROCEDURE IF EXISTS p_cal_dish_column$$
CREATE PROCEDURE p_cal_dish_column(IN i_cloumnId  VARCHAR(800),
                                   IN i_flag      INT(2),
                                   IN i_dz_amount DECIMAL(10, 2)
                                   )
SQL SECURITY INVOKER
COMMENT '处理dish 分类的实收字段'
BEGIN
  DECLARE v_sum_dishprice DECIMAL(10, 2);

  ### 不管是分类类型，还是“除分类”类型的优惠，都需要先根据传入的cloumnId找出的对应的记录
  ### 下面的程序，知道判定i_flag的值前，都是在做这件事件。并把结果集保存在t_temp_dish表中                         


  #这个临时表用来存储鱼锅的primarykey
  DROP TEMPORARY TABLE IF EXISTS t_temp_primarykey;
  CREATE TEMPORARY TABLE t_temp_primarykey
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #找出所有应用到优惠的鱼锅primarykey
  INSERT INTO t_temp_primarykey
  SELECT a.primarykey
  FROM
    t_temp_order_detail a, t_dish_dishtype b
  WHERE
    a.dishid = b.dishid
    AND find_in_set(b.columnid, i_cloumnId)
    AND a.orderprice IS NULL
    AND a.dishtype = '1';

  DROP TEMPORARY TABLE IF EXISTS t_temp_dish_hotpot;
  CREATE TEMPORARY TABLE t_temp_dish_hotpot
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  #找出所以应用到优惠的鱼锅明细
  INSERT INTO t_temp_dish_hotpot
  SELECT a.primarykey
       , a.dishnum * a.orderprice
       , a.debitamount
  FROM
    t_temp_order_detail a, t_temp_primarykey b
  WHERE
    a.parentkey = b.primarykey;


  #这个临时表用来存储使用优惠的菜品
  DROP TEMPORARY TABLE IF EXISTS t_temp_dish;
  CREATE TEMPORARY TABLE t_temp_dish
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dish
  #找出所有的普通菜品和套餐
  SELECT a.primarykey
       , a.dishnum * a.orderprice
       , a.debitamount
  FROM
    t_temp_order_detail a, t_dish_dishtype b
  WHERE
    a.dishid = b.dishid
    AND find_in_set(b.columnid, i_cloumnId)
    AND orderprice > 0
  UNION
  SELECT primarykey
       , orderprice
       , debitprice
  FROM
    t_temp_dish_hotpot;


  #分类优惠
  IF i_flag = 0 THEN

    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitprice IS NOT NULL THEN
             debitprice
           ELSE
             orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_dish;

    #计算实收价格
    IF v_sum_dishprice IS NOT NULL AND v_sum_dishprice != 0 THEN
      UPDATE t_temp_order_detail a, t_temp_dish b
      SET
        a.debitamount =
        CASE
        WHEN a.debitamount IS NOT NULL THEN
          a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
        ELSE
          a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
        END
      WHERE
        a.primarykey = b.primarykey;
    END IF;

  #针对“除某一分类”的优惠
  ELSE
    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitamount IS NOT NULL THEN
             debitamount
           ELSE
             dishnum * orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_order_detail
    WHERE
      orderprice > 0
      AND primarykey NOT IN (SELECT primarykey
                             FROM
                               t_temp_dish);


    #计算实收价格
    IF v_sum_dishprice IS NOT NULL AND v_sum_dishprice != 0 THEN

      UPDATE t_temp_order_detail a
      SET
        a.debitamount =
        CASE
        WHEN a.debitamount IS NOT NULL THEN
          a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
        ELSE
          a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
        END
      WHERE
        orderprice > 0
        AND primarykey NOT IN (SELECT primarykey
                               FROM
                                 t_temp_dish);
    END IF;
  END IF;


END
$$

DROP PROCEDURE IF EXISTS p_cal_dish_debit_amount$$
CREATE PROCEDURE p_cal_dish_debit_amount(IN  i_orderid VARCHAR(255),
                                         OUT o_message VARCHAR(255),
                                         OUT o_flag    INT
                                         )
SQL SECURITY INVOKER
COMMENT '计算单品的实收金额'
label_main:
BEGIN DECLARE v_fetch_done     NUMERIC DEFAULT 0;
  DECLARE v_coupondetailid VARCHAR(100);
  DECLARE v_caltype        INT(2);
  DECLARE v_dishtype       INT(2);
  DECLARE v_dishnum        INT(11);
  DECLARE v_dishid         VARCHAR(5000);
  DECLARE v_columnid       VARCHAR(5000);
  DECLARE v_orderdetailid  VARCHAR(100);
  DECLARE v_primarykey     VARCHAR(100);

  DECLARE v_sdetailid      VARCHAR(50);
  DECLARE v_payamount      DECIMAL(10, 2);
  DECLARE v_payway         INT(2);
  DECLARE v_couponNum      INT(3);
  DECLARE v_ys_amount      DECIMAL(10, 2);
  DECLARE v_bankcardno     VARCHAR(100);
  DECLARE v_coupon_count   INT;
  DECLARE v_xz_amount      DECIMAL(10, 2);

  DECLARE cur_order CURSOR FOR
  SELECT t.sdetailid
       , t.payamount
       , t.bankcardno
       , t.payway
       , t.couponNum
       , t.coupondetailid
       , CASE
         WHEN caltype IS NULL THEN
           99
         ELSE
           caltype
         END caltype
       , b.dishtype
       , b.dishid
       , b.columnid
  FROM
    t_temp_settlement_detail t
  LEFT JOIN t_dish_cal_factor_temp b
  ON
  t.coupondetailid = b.coupondetailid
  ORDER BY
    caltype;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_fetch_done = 1;

  #创建订单详情临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail;
  CREATE TEMPORARY TABLE t_temp_order_detail
  (
    orderid VARCHAR(50),
    dishid VARCHAR(50),
    dishtype CHAR(1),
    dishnum DOUBLE(13, 2),
    orignalprice DOUBLE(13, 2),
    orderprice DOUBLE(13, 2),
    debitamount DOUBLE(13, 2),
    pricetype CHAR(1),
    childdishtype TINYINT,
    primarykey VARCHAR(50),
    parentkey VARCHAR(50),
    dishunit VARCHAR(100),
    ismaster VARCHAR(3),
    superkey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_order_detail
  SELECT orderid
       , dishid
       , dishtype
       , dishnum
       , orignalprice
       , orderprice
       , NULL
       , pricetype
       , childdishtype
       , primarykey
       , parentkey
       , dishunit
       , ismaster
       , superkey
  FROM
    t_order_detail t
  WHERE
    t.orderid = i_orderid;

  #创建结算明细临时内存表 
  DROP TEMPORARY TABLE IF EXISTS t_temp_settlement_detail;
  CREATE TEMPORARY TABLE t_temp_settlement_detail(
    sdetailid VARCHAR(50),
    orderid VARCHAR(50),
    payamount DECIMAL(10, 2),
    bankcardno VARCHAR(100),
    payway INT(2),
    couponNum INT(3),
    coupondetailid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  INSERT INTO t_temp_settlement_detail
  SELECT sdetailid
       , orderid
       , payamount
       , bankcardno
       , payway
       , couponNum
       , coupondetailid
  FROM
    t_settlement_detail tsd
  WHERE
    tsd.orderid = i_orderid
    AND tsd.payway IN (6, 7, 11, 12)
    AND tsd.payamount != 0;

  # 挂账多收的数据
  INSERT INTO t_temp_settlement_detail # 挂账多收的数据
  SELECT sdetailid
       , orderid
       , payamount
       , bankcardno
       , payway
       , couponNum
       , coupondetailid
  FROM
    t_settlement_detail tsd
  WHERE
    tsd.orderid = i_orderid
    AND tsd.payway = 5
    AND tsd.payamount < 0;

  #循环遍历使用的优惠券,计算每一张优惠券的减免金额
  OPEN cur_order;

loop_label:
  LOOP

    FETCH cur_order INTO v_sdetailid, v_payamount, v_bankcardno, v_payway, v_couponNum, v_coupondetailid, v_caltype, v_dishtype, v_dishid, v_columnid;

    #循环结束标识
    IF v_fetch_done THEN
      LEAVE loop_label;
    END IF;



    #0 单品 1 双拼锅 2 除单品 3 分类 4 除分类 5 整单
    #针对某一单品的优惠
    IF v_caltype = '0' THEN
      CALL p_cal_dish_single(v_dishid, '0', v_payamount);
    #针对双拼锅优免20做特殊处理
    ELSEIF v_caltype = '1' THEN
      CALL p_cal_double_hotpot(v_payamount);
    #针对“除某一单品”的优惠
    ELSEIF v_caltype = '2' THEN
      CALL p_cal_dish_single(v_dishid, '1', v_payamount);
    #针对某一分类的优惠
    ELSEIF v_caltype = '3' THEN
      CALL p_cal_dish_column(v_columnid, '0', v_payamount);
    #针对“除某一分类”的优惠
    ELSEIF v_caltype = '4' THEN
      CALL p_cal_dish_column(v_columnid, '1', v_payamount);
    #整单优免
    ELSEIF v_caltype = '5' THEN
      CALL p_cal_whole_order(v_payamount);
    #抹零的情况没有coupondetailid
    ELSE
      CALL p_cal_whole_order(v_payamount);
    END IF;
  END LOOP;
  CLOSE cur_order;

  #把虚增按菜价均摊到每个菜上
  SELECT ifnull(sum(Inflated), 0)
  INTO
    v_xz_amount
  FROM
    t_order_member
  WHERE
    orderid = i_orderId;

  IF v_xz_amount > 0 THEN
    CALL p_cal_whole_order(v_xz_amount);
  END IF;

  #最后集中对套餐处理一下
  CALL p_cal_dishset_price();

  #没有使用到优惠的菜品，实收就是订单价格
  UPDATE t_temp_order_detail
  SET
    debitamount = orderprice * dishnum
  WHERE
    debitamount IS NULL;

  #把四舍五入的零头调完美
  SELECT ifnull(sum(t.payamount) - v_xz_amount, 0)
  INTO
    @amount1
  FROM
    t_settlement_detail t
  WHERE
    t.orderid = i_orderid
    AND t.payamount > 0
    AND t.payway IN (0, 1, 5, 8, 13, 17, 18);

  SELECT ifnull(sum(t.debitamount), 0)
  INTO
    @amount2
  FROM
    t_temp_order_detail t
  WHERE
    t.dishtype = 2
    AND t.primarykey = t.superkey;

  SELECT ifnull(sum(t.debitamount), 0)
  INTO
    @amount3
  FROM
    t_temp_order_detail t;

  SET @amount4 = @amount1 - (@amount3 - @amount2);

  IF @amount4 != 0 THEN
    SELECT primarykey
    INTO
      @key
    FROM
      t_temp_order_detail t
    WHERE
      t.dishtype IN (0, 1)
      OR (t.dishtype = 2
      AND t.primarykey != t.superkey)
    LIMIT
      1;

    UPDATE t_temp_order_detail
    SET
      debitamount = debitamount + @amount4
    WHERE
      primarykey = @key;
  END IF;

  #将中间表中的结果更新到正式表中
  UPDATE t_order_detail a, t_temp_order_detail b
  SET
    a.debitamount = b.debitamount
  WHERE
    a.primarykey = b.primarykey;

END
$$

DROP PROCEDURE IF EXISTS p_cal_dish_single$$
CREATE PROCEDURE p_cal_dish_single(IN i_dishid    VARCHAR(800),
                                   IN i_flag      INT(2),
                                   IN i_dz_amount DECIMAL(10, 2)
                                   )
SQL SECURITY INVOKER
COMMENT '处理单品的实收字段'
BEGIN
  DECLARE v_sum_dishprice DECIMAL(10, 2);

  ### 不管是单品类型，还是“除单品”类型的优惠，都需要先根据传入的dishid找出的对应的记录
  ### 下面的程序，知道判定i_flag的值前，都是在做这件事件。并把结果集保存在t_temp_dish表中                         

  #这个临时表用来存储鱼锅的primarykey
  DROP TEMPORARY TABLE IF EXISTS t_temp_primarykey;
  CREATE TEMPORARY TABLE t_temp_primarykey
  (
    primarykey VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  #找出所有应用到优惠的鱼锅primarykey
  INSERT INTO t_temp_primarykey
  SELECT primarykey
  FROM
    t_temp_order_detail
  WHERE
    find_in_set(dishid, i_dishid)
    AND orderprice IS NULL
    AND dishtype = '1';

  DROP TEMPORARY TABLE IF EXISTS t_temp_dish_hotpot;
  CREATE TEMPORARY TABLE t_temp_dish_hotpot
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;
  #找出所以应用到优惠的鱼锅明细
  INSERT INTO t_temp_dish_hotpot
  SELECT a.primarykey
       , a.dishnum * a.orderprice
       , a.debitamount
  FROM
    t_temp_order_detail a, t_temp_primarykey b
  WHERE
    a.parentkey = b.primarykey;


  #这个临时表用来存储使用优惠的菜品
  DROP TEMPORARY TABLE IF EXISTS t_temp_dish;
  CREATE TEMPORARY TABLE t_temp_dish
  (
    primarykey VARCHAR(50),
    orderprice DECIMAL(10, 2),
    debitprice DECIMAL(10, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dish
  #找出所有的普通菜品和套餐
  SELECT primarykey
       , dishnum * orderprice
       , debitamount
  FROM
    t_temp_order_detail
  WHERE
    find_in_set(dishid, i_dishid)
    AND orderprice > 0
  UNION
  SELECT primarykey
       , orderprice
       , debitprice
  FROM
    t_temp_dish_hotpot;

  #单品优惠
  IF i_flag = 0 THEN

    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitprice IS NOT NULL THEN
             debitprice
           ELSE
             orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_dish;

    #计算实收价格
    IF v_sum_dishprice IS NOT NULL AND v_sum_dishprice != 0 THEN
      UPDATE t_temp_order_detail a, t_temp_dish b
      SET
        a.debitamount =
        CASE
        WHEN a.debitamount IS NOT NULL THEN
          a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
        ELSE
          a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
        END
      WHERE
        a.primarykey = b.primarykey;
    END IF;


  #针对“除某一单品”的优惠
  ELSE
    #计算菜品总额
    SELECT sum(
           CASE
           WHEN debitamount IS NOT NULL THEN
             debitamount
           ELSE
             dishnum * orderprice
           END)
    INTO
      v_sum_dishprice
    FROM
      t_temp_order_detail
    WHERE
      orderprice > 0
      AND primarykey NOT IN (SELECT primarykey
                             FROM
                               t_temp_dish);


    #计算实收价格
    IF v_sum_dishprice IS NOT NULL AND v_sum_dishprice != 0 THEN

      UPDATE t_temp_order_detail a
      SET
        a.debitamount =
        CASE
        WHEN a.debitamount IS NOT NULL THEN
          a.debitamount - (a.debitamount / v_sum_dishprice) * i_dz_amount
        ELSE
          a.orderprice * a.dishnum - (a.dishnum * a.orderprice / v_sum_dishprice) * i_dz_amount
        END
      WHERE
        orderprice > 0
        AND primarykey NOT IN (SELECT primarykey
                               FROM
                                 t_temp_dish);
    END IF;
  END IF;
END
$$

DROP PROCEDURE IF EXISTS p_cal_double_hotpot$$
CREATE PROCEDURE p_cal_double_hotpot(IN i_dz_amount DECIMAL(10, 2))
SQL SECURITY INVOKER
COMMENT '处理整单优惠的情况'
BEGIN

  DECLARE v_sum_dishprice     DECIMAL(10, 2);
  DECLARE v_double_hotpot_key VARCHAR(50) DEFAULT NULL;

  #找出双拼锅
  SELECT parentkey
  INTO
    v_double_hotpot_key
  FROM
    t_temp_order_detail
  WHERE
    dishtype = 1
    AND orderprice > 0
  GROUP BY
    parentkey
  HAVING
    count(1) = 4
  LIMIT
    1;

  #将双拼锅优惠均摊到2个锅底和2个鱼上
  IF v_double_hotpot_key IS NOT NULL THEN
    UPDATE t_temp_order_detail
    SET
      debitamount =
      CASE
      WHEN debitamount IS NOT NULL THEN
        debitamount - i_dz_amount / 4
      ELSE
        orderprice * dishnum - i_dz_amount / 4
      END
    WHERE
      parentkey = v_double_hotpot_key;
  END IF;

END
$$

DROP PROCEDURE IF EXISTS p_cal_whole_order$$
CREATE PROCEDURE p_cal_whole_order(IN i_dz_amount DECIMAL(10, 2))
SQL SECURITY INVOKER
COMMENT '处理整单优惠的情况'
BEGIN

  DECLARE v_sum_dishprice DECIMAL(10, 2);

  #计算总价格
  SELECT sum(
         CASE
         WHEN debitamount IS NOT NULL THEN
           debitamount
         ELSE
           dishnum * orderprice
         END)
  INTO
    v_sum_dishprice
  FROM
    t_temp_order_detail
  WHERE
    orderprice > 0;

  #计算每个菜品的实收价格
  IF v_sum_dishprice IS NOT NULL AND v_sum_dishprice != 0 THEN
    UPDATE t_temp_order_detail
    SET
      debitamount =
      CASE
      WHEN debitamount IS NOT NULL THEN
        debitamount - (debitamount / v_sum_dishprice) * i_dz_amount
      ELSE
        orderprice * dishnum - (dishnum * orderprice / v_sum_dishprice) * i_dz_amount
      END
    WHERE
      orderprice > 0;
  END IF;
END
$$



--
-- Definition for procedure p_calcDishPrice
--
DROP PROCEDURE IF EXISTS p_calcDishPrice$$
CREATE PROCEDURE p_calcDishPrice(IN i_orderId varchar(255))
  SQL SECURITY INVOKER
BEGIN


  DECLARE v_message varchar(255);
  DECLARE v_flag int;

  CALL newspicyway.p_cal_dish_debit_amount(i_orderId, v_message, v_flag);

END
$$

--
-- Definition for procedure p_calcDishSetPrice
--
DROP PROCEDURE IF EXISTS p_calcDishSetPrice$$
CREATE PROCEDURE p_calcDishSetPrice(IN i_orderId varchar(255))
  SQL SECURITY INVOKER
BEGIN
      DECLARE v_message varchar(255);
  DECLARE v_flag int;

  CALL newspicyway.p_cal_dish_debit_amount(i_orderId, v_message, v_flag);
END
$$

--
-- Definition for procedure p_caletableamount
--
DROP PROCEDURE IF EXISTS p_caletableamount$$
CREATE PROCEDURE p_caletableamount(IN v_orderid varchar(50))
  SQL SECURITY INVOKER
BEGIN
  DECLARE v_couponname varchar(100);
  DECLARE v_fulldiscountrate decimal(10,2);
  declare v_dueamount  decimal(10,2);
  declare v_ssamount decimal(10,2);
  declare v_gzamount decimal(10,2);
  declare v_ymamount decimal(10,2);
  declare v_originalOrderAmount decimal(10,2);
  select a.fulldiscountrate,couponname INTO  v_fulldiscountrate,v_couponname from t_order a    where orderid=v_orderid;
  
  set v_fulldiscountrate = 1;
  update t_order_detail set discountrate=1 where orderid=v_orderid; 
  update t_order_detail set payamount=0, discountamount=0,predisamount=0  where ((status<>5 and  (not (orderprice>0))) or (status=5))  and orderid=v_orderid;
  update t_order_detail set payamount=orderprice*dishnum*(case when discountrate<=0 then 1 else discountrate end), discountamount=orderprice*dishnum*(1-case when discountrate<=0 then 1 else discountrate end),predisamount=orderprice*dishnum  where    status<>5 and  orderprice>0  and orderid=v_orderid;
  select IFNULL(sum(payamount),0) into v_dueamount from t_order_detail where   status<>5 and  orderid=v_orderid ;
  select IFNULL(sum(payamount),0) into v_ssamount from t_settlement_detail where orderid=v_orderid and payway in(SELECT itemid FROM `v_revenuepayway`);
  select IFNULL(sum(payamount),0) into v_gzamount from t_settlement_detail where orderid=v_orderid and payway in(5,13);
  select IFNULL(sum(payamount),0) into v_ymamount from t_settlement_detail where orderid=v_orderid and payway in(6,12);
  select IFNULL(sum( tod.dishnum * tod.orignalprice ),0) INTO v_originalOrderAmount FROM t_order_detail AS tod WHERE ( tod.dishtype = 0 OR ( tod.dishtype = 2 AND EXISTS ( SELECT tdg.dishid FROM t_dish_group tdg WHERE tod.dishid = tdg.dishid ) ) ) AND tod.orderid = v_orderid;
  update t_order set dueamount=v_dueamount,wipeamount=v_dueamount-floor(v_dueamount),ssamount=v_ssamount,gzamount=v_gzamount,ymamount=v_ymamount,freeamount=v_originalOrderAmount where orderid=v_orderid;
END
$$

--
-- Definition for procedure p_cal_dishset_price
--
DROP PROCEDURE IF EXISTS p_cal_dishset_price$$
CREATE PROCEDURE p_cal_dishset_price()
  SQL SECURITY INVOKER
  COMMENT '计算套餐的实收金额'
BEGIN
  DECLARE v_fetch_done           NUMERIC DEFAULT 0;
  DECLARE v_primarykey           VARCHAR(50);
  DECLARE v_dishset_debitamount  DECIMAL(10, 2);
  DECLARE v_dishset_orignalprice DECIMAL(10, 2);

  DECLARE cur_dish_set CURSOR FOR
  SELECT *
  FROM
    t_temp_dishset tod;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_fetch_done = 1;


  
  UPDATE t_temp_order_detail
  SET
    debitamount = dishnum * orderprice
  WHERE
    dishtype = '2'
    AND primarykey = superkey
    AND debitamount IS NULL;

  
  DROP TEMPORARY TABLE IF EXISTS t_temp_dishset;
  CREATE TEMPORARY TABLE t_temp_dishset
  (
    primarykey VARCHAR(50),
    debitamount DOUBLE(13, 2)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8 MAX_ROWS = 1000000;

  INSERT INTO t_temp_dishset
  SELECT primarykey
       , debitamount
  FROM
    t_temp_order_detail tod
  WHERE
    dishtype = '2'
    AND primarykey = superkey;

  OPEN cur_dish_set;

loop_lable:
  LOOP
    FETCH cur_dish_set INTO v_primarykey, v_dishset_debitamount;

    
    SELECT sum(ifnull(dishnum * orignalprice, 0))
    INTO
      v_dishset_orignalprice
    FROM
      t_temp_order_detail
    WHERE
      superkey = v_primarykey
      AND primarykey != v_primarykey;

    
    IF v_fetch_done THEN
      LEAVE loop_lable;
    END IF;

    UPDATE t_temp_order_detail
    SET
      debitamount = dishnum * orignalprice / v_dishset_orignalprice * v_dishset_debitamount
    WHERE
      superkey = v_primarykey
      AND primarykey != v_primarykey;
  END LOOP;
  CLOSE cur_dish_set;
END
$$




--
-- Definition for procedure p_endwork
--
DROP PROCEDURE IF EXISTS p_endwork$$
CREATE PROCEDURE p_endwork(OUT v_endfinish BIT)
SQL SECURITY INVOKER
BEGIN
  DECLARE t_error    INTEGER DEFAULT 0;
  DECLARE v_branchid VARCHAR(50);
  DECLARE v_tenantid VARCHAR(50);
  DECLARE v_now      DATETIME;
  DECLARE v_opendate DATETIME;
  DECLARE v_username VARCHAR(20);

  -- 异常处理模块，出现异常回滚(20151204 shangwenchao added)
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
  	set t_error = 1;
  	set v_endfinish = false;
    ROLLBACK;
  END;


  # 初始化数据 (20151204 shangwenchao added)
  SET v_now = now();
  # 分店id 和 租户id
  SELECT branchid
       , tenantid
  INTO
    v_branchid, v_tenantid
  FROM
    t_branch_info
  LIMIT
    1;

  # 开业日期 和 用户
  SELECT opendate
       , username
  INTO
    v_opendate, v_username
  FROM
    t_open_log
  LIMIT
    1;



  START TRANSACTION;

  INSERT INTO t_biz_log (id, branchid, tenantid, syn_status, inserttime, open_date, end_date, open_user) VALUES (uuid(), v_branchid, v_tenantid, 1, v_now, v_opendate, v_now, v_username);

  DELETE
  FROM
    t_branch_biz_log;

  INSERT INTO t_branch_biz_log (id, opendate, enddate, openuser, enduser, inserttime, branchid) VALUES (uuid(), v_opendate, v_now, v_username, NULL, v_now, v_branchid);

  DELETE
  FROM
    t_open_log;


  DELETE
  FROM
    t_json_record;

  UPDATE tableseqno
  SET
    val = 2
  WHERE
    name IN ('printobjid', 'printdishid');

  DELETE
  FROM
    t_printobj;

  DELETE
  FROM
    t_printdish;

  UPDATE t_printer
  SET
    printnum = 0;

  UPDATE t_table
  SET
    orderid = '';

  UPDATE t_b_user
  SET
    order_num = NULL, lastlogintime = NULL;

  UPDATE sequence
  SET
    val = 1
  WHERE
    name = 'one';

  INSERT INTO t_syn_sql_history
  SELECT *
  FROM
    t_syn_sql;

  DELETE
  FROM
    t_syn_sql;

  # 20151204 shangwenchao added
  # 情空消息推送信息
  DELETE
  FROM
    t_syncclient;
  DELETE
  FROM
    t_syncmsg;



  IF t_error = 1 THEN
    SET v_endfinish = FALSE;
    ROLLBACK;
  ELSE
    SET v_endfinish = TRUE;
    COMMIT;
	
	CALL p_check_source_data(v_branchid, v_opendate, v_now); #结业成功后，检查所有的单子实收是否计算正确
  END IF;

END
$$

--
-- Definition for procedure p_mergetable
--
DROP PROCEDURE IF EXISTS p_mergetable$$
CREATE PROCEDURE p_mergetable(IN i_targettableno varchar(50), IN i_orignaltableno varchar(50), INOUT o_result varchar(50))
  SQL SECURITY INVOKER
BEGIN

  DECLARE v_count int;
  DECLARE v_r_status varchar(2);
  DECLARE v_r_order varchar(100);
  DECLARE v_target_order_id varchar(100);
  DECLARE v_d_orderid varchar(100);
  DECLARE v_status varchar(2);
  DECLARE v_orderid varchar(100);
  DECLARE v_tableid varchar(100);
  declare v_man_num  int;
  declare v_woman_num  int;
  declare v_person_num int;
  declare v_child_num int;
  declare v_ageperiod  varchar(100);
  declare v_t_man_num  int;
  declare v_t_woman_num  int;
  declare v_t_person_num int;
  declare v_t_ageperiod  varchar(100);
  declare v_t_child_num int;

  DECLARE v_t_tableid varchar(100);
  DECLARE v_t_tableid_t varchar(100);
  DECLARE v_t_status varchar(2);
  DECLARE v_t_orderid varchar(100);
  DECLARE v_orderstatus int;
  DECLARE v_t_orderstatus int;
  DECLARE v_relateorderid varchar(3000);
  DECLARE v_t_relateorderid varchar(300);
  declare v_memberno  varchar(50);
  declare v_t_memberno  varchar(50);
  declare v_menuid  varchar(100);

  
   
SELECT
    COUNT(1) INTO v_count
  FROM t_table
  WHERE tableno = i_orignaltableno;

 
   select menuid into v_menuid   from v_currmenu;

  
 
IF v_count = 1 THEN
    
 
SELECT
      COUNT(1) INTO v_count
    FROM t_table
    WHERE tableno = i_targettableno;
 

    
 
IF v_count = 1 THEN


     
SELECT
        status,
        orderid,
        tableid INTO v_status, v_orderid, v_tableid
      FROM t_table
      WHERE tableno = i_orignaltableno;
 

      

    
SELECT
        status,
        orderid,
        tableid INTO v_t_status, v_t_orderid, v_t_tableid_t
      FROM t_table
      WHERE tableno = i_targettableno;
 
 
if v_orderid = v_t_orderid then
         
SET o_result = '0';
 
      else
             
     
IF v_orderid IS NOT NULL THEN
           
        
SELECT
          t.relateorderid,
          orderstatus,custnum,womanNum,childNum,mannum,ageperiod,memberno
       INTO v_relateorderid, v_orderstatus,v_person_num,v_woman_num,v_child_num,v_man_num,v_ageperiod,v_memberno
        FROM t_order t
        WHERE t.orderid = v_orderid;
 
        
    
IF v_orderstatus != 3 AND v_orderstatus != 2 THEN
          
         
IF v_t_orderid IS NOT NULL THEN

       
         
SELECT
              t.relateorderid,
              orderstatus ,custnum,womanNum,childNum,mannum,ageperiod,memberno
            INTO v_t_relateorderid, v_t_orderstatus,v_t_person_num,v_t_woman_num,
                 v_t_child_num,v_t_man_num,v_t_ageperiod,v_t_memberno
            FROM t_order t
            WHERE t.orderid = v_t_orderid;
 
IF v_t_orderstatus != 3  and v_t_orderstatus != 2  THEN

             
       if v_memberno is null and v_t_memberno is not null then
          
           update t_order set memberno = v_t_memberno 
           where orderid = v_orderid;

          call newspicyway.p_update2vipprice(v_orderid);
 
       else 
           if v_memberno is not null  and v_t_memberno is null then
             
             update t_order set memberno = v_memberno 
             where orderid = v_t_orderid;

            call newspicyway.p_update2vipprice(v_t_orderid);

           end if;
       end if; 
 
IF v_t_relateorderid IS NULL
                OR v_t_relateorderid = '' THEN

   
          
        UPDATE t_order_detail
													SET orderid = v_orderid
													WHERE orderid = v_t_orderid;


           update t_printdish set printobjid = (select id from t_printobj where orderno =v_orderid)
           where printobjid = (select id from t_printobj where orderno = v_t_orderid);
					 
													
												 
					UPDATE t_order_detail_discard
													SET orderid = v_orderid
													WHERE orderid = v_t_orderid;
 


											
										 
			UPDATE t_table
											SET orderid = v_orderid,status ='1'
											WHERE tableid = v_t_tableid_t;
			 

											
											
			UPDATE t_order
											SET payway = '1',
													relateorderid = CONCAT(v_tableid, ',', v_t_tableid_t),
													custnum = custnum + ifnull(v_t_person_num,0),
													womanNum = womanNum + ifnull(v_t_woman_num,0),
													 childNum = childNum + ifnull(v_t_child_num,0),
													mannum = mannum + ifnull(v_t_man_num,0),
													ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
													memberno = ifNUll(v_memberno,v_t_memberno)
											WHERE orderid = v_orderid;


    UPDATE t_printobj SET custnum = custnum + ifnull(v_t_person_num,0) WHERE orderno = v_orderid;
 
					 
IF v_t_orderid!=v_orderid AND v_t_orderid IS NOT NULL THEN
                
				DELETE
													FROM t_order
												WHERE orderid = v_t_orderid;
				 
											END IF;

 ELSE

                
         
			UPDATE t_table
											SET orderid = v_orderid
											WHERE orderid = v_t_orderid;
 

                
             
UPDATE t_order_detail
                SET orderid = v_orderid
                WHERE orderid = v_t_orderid;
 

                
   
UPDATE t_order_detail_discard
                SET orderid = v_orderid
                WHERE orderid = v_t_orderid;

           update t_printdish set printobjid = (select id from t_printobj where orderno =v_orderid)
           where printobjid = (select id from t_printobj where orderno = v_t_orderid);
 

                

              
UPDATE t_order
                SET relateorderid = CONCAT(IFNULL(v_relateorderid, v_tableid), ',', v_t_relateorderid),
                    custnum = custnum + ifnull(v_t_person_num,0),
                    womanNum = womanNum + ifnull(v_t_woman_num,0),
                     childNum = childNum + ifnull(v_t_child_num,0),
                    mannum = mannum + ifnull(v_t_man_num,0),
                    ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
                    memberno = ifNUll(v_memberno,v_t_memberno)
                WHERE orderid = v_orderid;
 

    UPDATE t_printobj SET custnum = custnum + ifnull(v_t_person_num,0) WHERE orderno = v_orderid;
                
							 
IF v_t_orderid!=v_orderid AND v_t_orderid IS NOT NULL THEN
            
                  DELETE
                  FROM t_order
                WHERE orderid = v_t_orderid;
 
								END IF;
              END IF;
ELSE
              
 
            
        UPDATE t_table
              SET status = '1',orderid = v_orderid
              WHERE tableid = v_t_tableid_t;
 

              
              
        UPDATE t_order
              SET payway = '1',
                  relateorderid = CONCAT(v_tableid, ',', v_t_tableid_t),
                    custnum = custnum + ifnull(v_t_person_num,0),
                    womanNum = womanNum + ifnull(v_t_woman_num,0),
                     childNum = childNum + ifnull(v_t_child_num,0),
                    mannum = mannum + ifnull(v_t_man_num,0),
                    ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
                    memberno = ifNUll(v_memberno,v_t_memberno)
              WHERE orderid = v_orderid;

    UPDATE t_printobj SET custnum = custnum + ifnull(v_t_person_num,0) WHERE orderno = v_orderid;

            END IF;
          ELSE
            
        
         UPDATE t_table
												SET status = '1',
														orderid = v_orderid
												WHERE tableid = v_t_tableid_t;
						 

												
												 
						UPDATE t_order
												SET payway = '1',
														relateorderid = CONCAT(v_tableid, ',', v_t_tableid_t),
																custnum = custnum + ifnull(v_t_person_num,0),
																womanNum = womanNum + ifnull(v_t_woman_num,0),
																 childNum = childNum + ifnull(v_t_child_num,0),
																mannum = mannum + ifnull(v_t_man_num,0),
																ageperiod = CONCAT(ageperiod,ifnull(v_t_ageperiod,'')),
																memberno = ifNUll(v_memberno,v_t_memberno)
												WHERE orderid = v_orderid;
 

    UPDATE t_printobj SET custnum = custnum + ifnull(v_t_person_num,0) WHERE orderno = v_orderid;

          END IF;

        END IF;

      END IF;

      end if;

   
     
SET o_result = '0';
 
    ELSE
     
SET o_result = '1';
 
    END IF;
  ELSE
     
SET o_result = '1';
 
  END IF;

 
END
$$

--
-- Definition for procedure p_orderdish
--
DROP PROCEDURE IF EXISTS `p_orderdish`$$
CREATE PROCEDURE `p_orderdish`(IN i_orderid varchar(50), IN i_printobjid int, INOUT o_code varchar(50), INOUT o_msg varchar(300))
    SQL SECURITY INVOKER
label_main:
  BEGIN

    DECLARE flag int;

    DECLARE v_g_printobjid int;

    DECLARE v_r_status varchar(2);

    DECLARE V_TABLEID varchar(100);

    DECLARE v_order varchar(100);

    DECLARE v_printobj_count int;

    DECLARE v_printdish_count int;

    DECLARE v_tablearea varchar(100) CHARACTER SET utf8;

    DECLARE v_orderid varchar(50);

    DECLARE v_tableno varchar(100) CHARACTER SET utf8;

    DECLARE v_dishid varchar(50);

    DECLARE v_dishstatus varchar(50);

    DECLARE v_begintime datetime;

    DECLARE v_endtime datetime;

    DECLARE v_sperequire varchar(200) CHARACTER SET utf8;

    DECLARE v_dishnum varchar(50);

    DECLARE v_userName varchar(100) CHARACTER SET utf8;

    DECLARE v_orderprice decimal(10, 2);

    DECLARE v_discountrate decimal(10, 2);

    DECLARE v_discountamount decimal(10, 2);

    DECLARE v_fishcode varchar(50);

    DECLARE v_dishtype int(11);

    DECLARE v_status int(11);

    DECLARE v_dishunit varchar(50) CHARACTER SET utf8;

    DECLARE v_payamount decimal(10, 2);

    DECLARE v_predisamount decimal(10, 2);

    DECLARE v_couponid varchar(50);

    DECLARE v_disuserid varchar(50);

    DECLARE v_orignalprice decimal(10, 2);

    DECLARE v_pricetype varchar(10);

    DECLARE v_printtype varchar(10);

    DECLARE v_printdishid int;

    DECLARE v_maxDishCount int;

    DECLARE v_printaddress varchar(100);

    DECLARE v_printport varchar(10);

    DECLARE v_timemsg varchar(30);

    DECLARE v_customeraddress varchar(100);

    DECLARE v_customerport varchar(10);

    DECLARE v_relatedishid varchar(4000);

    DECLARE v_orderseq integer;

    DECLARE v_dishname varchar(300) CHARACTER SET utf8;

    DECLARE v_full_name varchar(30) CHARACTER SET utf8;

    DECLARE done int DEFAULT 0;

    DECLARE tmpFlag int;

    DECLARE v_printer varchar(100);

    DECLARE v_ordertype int;

    DECLARE v_parentkey varchar(255);

    DECLARE v_superkey varchar(255);

    DECLARE v_ismaster int;

    DECLARE v_primarykey varchar(255);

    DECLARE v_islatecooke int;

    DECLARE v_isadddish int;

    DECLARE v_childdishtype int;

    DECLARE v_ispot int;

    DECLARE v_dish_count int;

    DECLARE v_menu_dish_count int;

    DECLARE v_branch_id varchar(50);

    DECLARE v_order_detail_count int;

    DECLARE v_menuid varchar(50);

    DECLARE autocommit int;

    DECLARE cur_order CURSOR FOR

    SELECT
      orderid,
      dishid,
      dishstatus,
      begintime,
      endtime,
      sperequire,
      dishnum,
      username,
      orderprice,
      discountrate,
      discountamount,
      fishcode,
      dishtype,
      status,
      dishunit,
      payamount,
      predisamount,
      couponid,
      username,
      orignalprice,
      pricetype,
      printtype,
      relatedishid,
      ordertype,
      parentkey,
      superkey,
      ismaster,
      primarykey,
      islatecooke,
      isadddish,
      childdishtype,
      ispot
    FROM t_order_detail_temp t
    WHERE t.orderid = i_orderid FOR UPDATE;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
      ##其他错误 code 3
      SET o_code = '3';
      GET DIAGNOSTICS CONDITION 1 o_msg = MESSAGE_TEXT;
      ##删除临时表
      DELETE
        FROM t_order_detail_temp
      WHERE orderid = i_orderid;
    END;

    SELECT
      COUNT(1) INTO v_order_detail_count
    FROM t_order_detail
    WHERE orderid = i_orderid;

    IF v_order_detail_count = 0 THEN
      SET v_orderseq = 1;
    ELSE
      SELECT
        MAX(orderseq) + 1 INTO v_orderseq
      FROM t_order_detail
      WHERE orderid = i_orderid;
    END IF;

    SELECT
      tm.menuid INTO v_menuid
    FROM t_branch_info tbf,
         t_menu_branch mb,
         t_menu tm
    WHERE tbf.branchid = mb.branchid
    AND mb.menuid = tm.menuid
    AND tm.status = '1'
    ORDER BY tm.effecttime DESC LIMIT 1;

    IF done = 1 THEN
      SET o_code = '1';
      SET o_msg = '菜谱更新中';

      ##删除临时表
      DELETE
        FROM t_order_detail_temp
      WHERE orderid = i_orderid;

      LEAVE label_main;
    END IF;

    OPEN cur_order;

    REPEAT

      FETCH cur_order INTO v_orderid,

      v_dishid,

      v_dishstatus,

      v_begintime,

      v_endtime,

      v_sperequire,

      v_dishnum,

      v_userName,

      v_orderprice,

      v_discountrate,

      v_discountamount,

      v_fishcode,

      v_dishtype,

      v_status,

      v_dishunit,

      v_payamount,

      v_predisamount,

      v_couponid,

      v_disuserid,

      v_orignalprice,

      v_pricetype,

      v_printtype,

      v_relatedishid,

      v_ordertype,

      v_parentkey,

      v_superkey,

      v_ismaster,

      v_primarykey,

      v_islatecooke,

      v_isadddish,

      v_childdishtype,

      v_ispot;

      IF done <> 1 THEN

        INSERT INTO t_order_detail (orderdetailid, orderid, dishid, dishstatus, begintime, endtime, sperequire, dishnum,
        username, orderprice, discountrate, discountamount, fishcode,
        dishtype, status, dishunit, payamount, predisamount,
        couponid, disuserid, orignalprice,
        pricetype, orderseq, relatedishid,
        ordertype,
        parentkey,
        superkey,
        ismaster,
        primarykey,
        islatecooke,
        isadddish,
        childdishtype,
        ispot)
          VALUES (UUID(), v_orderid, v_dishid, v_dishstatus, v_begintime, v_endtime, v_sperequire, v_dishnum, v_userName, v_orderprice, v_discountrate, v_discountamount, v_fishcode, v_dishtype, v_status, v_dishunit, v_payamount, v_predisamount, v_couponid, v_disuserid, v_orignalprice, v_pricetype, v_orderseq, v_relatedishid, v_ordertype, v_parentkey, v_superkey, v_ismaster, v_primarykey, v_printtype, v_isadddish, v_childdishtype, v_ispot);

        SELECT
          tableseqno('printdishid') INTO v_printdishid;

        SELECT
          COUNT(1) INTO v_dish_count
        FROM t_dish td
        WHERE dishid = v_dishid;

        IF v_dish_count > 0 THEN

          SELECT
            COUNT(1) INTO v_menu_dish_count
          FROM t_template_dishunit
          WHERE menuid = v_menuid
          AND dishid = v_dishid;

          IF v_menu_dish_count > 0 THEN

            SELECT
              IFNULL(dishname, '') INTO v_dishname
            FROM t_template_dishunit
            WHERE menuid = v_menuid
            AND dishid = v_dishid LIMIT 1;

          ELSE

            SELECT
              td.title INTO v_dishname
            FROM t_dish td
            WHERE dishid = v_dishid;

          END IF;

					ELSE 
						SET o_code = '2';
						SET o_msg = '菜品更新中';

						##删除临时表
						DELETE
							FROM t_order_detail_temp
						WHERE orderid = i_orderid;

						LEAVE label_main;
        END IF;

        IF done = 1 THEN
          SET o_code = '2';
          SET o_msg = '菜品更新中';

          ##删除临时表
          DELETE
            FROM t_order_detail_temp
          WHERE orderid = i_orderid;

          LEAVE label_main;
        END IF;

        SELECT
          currenttableid INTO V_TABLEID
        FROM t_order T
        WHERE T.orderid = v_orderid;


        SELECT
          CONCAT('桌号:', ' ', IFNULL(tableno, '')) INTO v_tableno
        FROM t_tablearea ta,
             t_table tb
        WHERE tb.areaid = ta.areaid
        AND tb.tableid = V_TABLEID;


        IF v_dishtype IS NOT NULL
          AND v_dishtype = '1'
          AND v_parentkey != v_primarykey THEN
          SET v_dishname = CONCAT('-', v_dishname);

        END IF;

        IF v_dishtype IS NOT NULL
          AND v_dishtype = '2'
          AND v_parentkey != v_primarykey THEN
          SET v_dishname = CONCAT('-', v_dishname);
        END IF;


        INSERT INTO t_printdish (printdishid
        , printobjid
        , dishname
        , dishnum
        , dishprice
        , totalamount
        , payamount
        , sperequire
        , tableNomsg
        , dishunit
        , printipaddress
        , printport
        , printnum
        , dishid
        , printtype
        , relatedishid
        , orderseq
        , dishtype
        , printerId,
        ordertype,
        parentkey,
        superkey,
        ismaster,
        primarykey,
        islatecooke,
        isadddish,
        childdishtype,
        ispot)

          VALUES (v_printdishid, i_printobjid, v_dishname, v_dishnum, v_orderprice, 0, 0, v_sperequire, v_tableno, v_dishunit, v_printaddress, v_pricetype, '0', v_dishid, IFNULL(v_printtype, 2), v_relatedishid, v_orderseq, v_dishtype, v_printer, v_ordertype, v_parentkey, v_superkey, v_ismaster, v_primarykey, v_printtype, v_isadddish, v_childdishtype, v_ispot);


        SET v_dishname = NULL;
        SET v_printtype = NULL;

        IF done = 1 THEN
          SET o_code = '3';
          GET DIAGNOSTICS CONDITION 1 o_msg = MESSAGE_TEXT;

          ##删除临时表
          DELETE
            FROM t_order_detail_temp
          WHERE orderid = i_orderid;

          LEAVE label_main;
        END IF;

      END IF;

    UNTIL done = 1
    END REPEAT;

    CLOSE cur_order;

    SET done = 0;

    SELECT
      COUNT(1) INTO v_printobj_count
    FROM t_printobj tp

    WHERE tp.orderno = i_orderid;

    IF v_printobj_count = 0 THEN

      SELECT
        currenttableid INTO V_TABLEID
      FROM t_order T
      WHERE T.orderid = v_orderid;

      UPDATE t_order
      SET orderstatus = '0'
      WHERE orderid = v_orderid;

      SELECT
        CURRENT_TIMESTAMP() INTO v_timemsg;

      SELECT
        branchid INTO v_branch_id
      FROM t_branch_info LIMIT 1;

      SELECT
        name INTO v_full_name
      FROM t_b_user
      WHERE id
      IN (SELECT
          user_id
        FROM t_b_employee
        WHERE job_number = v_userName
        AND branch_id = v_branch_id);

      SELECT
        currenttableid INTO V_TABLEID
      FROM t_order T
      WHERE T.orderid = v_orderid;

      SELECT
        ta.areaname INTO v_tablearea
      FROM t_tablearea ta,
           t_table tb
      WHERE tb.areaid = ta.areaid
      AND tb.tableid = V_TABLEID;

      INSERT INTO t_printobj (id,
      printtype
      , orderno
      , username
      , tableno
      , timemsg
      , customerprinterip
      , customerprinterport
      , tableArea,
      tableid)

        VALUES (i_printobjid, '3', i_orderid, v_full_name, v_tableno, v_timemsg, v_customeraddress, v_customerport, v_tablearea, V_TABLEID);

    END IF;

    IF done = 1 THEN
      SET o_code = '3';
      GET DIAGNOSTICS CONDITION 1 o_msg = MESSAGE_TEXT;

      ##删除临时表
      DELETE
        FROM t_order_detail_temp
      WHERE orderid = i_orderid;

      LEAVE label_main;
    END IF;

    DELETE

      FROM t_order_detail_temp

    WHERE orderid = i_orderid;

    SET o_code = '0';
    SET o_msg = '下单成功';

  END
$$

--
-- Definition for procedure p_setOrderDish
--
DROP PROCEDURE IF EXISTS `p_setOrderDish`$$
CREATE PROCEDURE `p_setOrderDish`(IN i_orderid varchar(50), INOUT o_code varchar(50), INOUT o_msg varchar(300))
    SQL SECURITY INVOKER
BEGIN


  DECLARE v_printobjid int;

  DECLARE v_printobj_count int;


  SELECT

    COUNT(1) INTO v_printobj_count

  FROM t_printobj tp

  WHERE tp.orderno = i_orderid;


  IF v_printobj_count = 0 THEN


    SELECT

      tableseqno('printobjid') INTO v_printobjid;


  ELSE


    SELECT DISTINCT

      tp.id INTO v_printobjid

    FROM t_printobj tp

    WHERE tp.orderno = i_orderid;

  END IF;

  CALL newspicyway.p_orderdish(i_orderid, v_printobjid, o_code, o_msg);


END
$$

--
-- Definition for procedure p_setordermember
--
DROP PROCEDURE IF EXISTS p_setordermember$$
CREATE PROCEDURE p_setordermember(IN v_orderid varchar(50), IN v_pricetype int)
  SQL SECURITY INVOKER
BEGIN
  DECLARE done int default 0;
  DECLARE v_dishid varchar(50);
  DECLARE v_orderdetailid varchar(50);
  DECLARE v_dishunit varchar(100);
  DECLARE v_template_vipprice decimal(10, 2);
  declare v_menuid varchar(100);
  DECLARE cur_orderlist CURSOR FOR
  select a.dishid,a.orderdetailid,a.dishunit from t_order_detail a inner join t_dish b on(a.dishid=b.dishid) where a.orderprice>0 and a.orderid=v_orderid;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  select menuid into v_menuid from v_currmenu;
  OPEN cur_orderlist;
  REPEAT
    FETCH cur_orderlist INTO v_dishid, v_orderdetailid,v_dishunit;
    IF done <> 1 THEN
      if(v_pricetype=0)then
        select vipprice INTO v_template_vipprice from t_template_dishunit where (menuid =v_menuid or(dishid='DISHES_98')) and dishid=v_dishid and (unit=v_dishunit or (dishid='DISHES_98')) LIMIT 1;
       else
        select price INTO v_template_vipprice from t_template_dishunit where (menuid =v_menuid or(dishid='DISHES_98')) and dishid=v_dishid and (unit=v_dishunit or (dishid='DISHES_98')) LIMIT 1;
      END IF;
      if(v_template_vipprice>0)THEN
        update t_order_detail set orderprice=v_template_vipprice where orderid=v_orderid and orderdetailid=v_orderdetailid;
      end if;
   END IF;
  UNTIL done = 1
  END REPEAT;
  CLOSE cur_orderlist;
  CALL newspicyway.p_caletableamount(v_orderid);
END
$$


--
-- Definition for procedure p_start_cloud_menu
--
DROP PROCEDURE IF EXISTS p_start_cloud_menu$$
CREATE PROCEDURE p_start_cloud_menu()
  SQL SECURITY INVOKER
BEGIN

  UPDATE t_menu tm SET tm.status='1' WHERE tm.status='2' AND tm.effecttime<=NOW();
END
$$

--
-- Definition for procedure p_switch
--
DROP PROCEDURE IF EXISTS p_switch$$
CREATE PROCEDURE p_switch(IN i_targettableno varchar(50), IN i_orignaltableno varchar(50), INOUT o_result varchar(50))
  SQL SECURITY INVOKER
BEGIN
  DECLARE v_count int;
  DECLARE v_status varchar(2);
  DECLARE v_orderid varchar(100);
  DECLARE v_t_orderid varchar(100);
  DECLARE v_table_orginal_id varchar(100);

  DECLARE v_tableid varchar(100);
  DECLARE v_orderstatus varchar(2);
  DECLARE v_t_orderstatus varchar(2);

  DECLARE v_tableno  varchar(300);

  SELECT
    COUNT(1) INTO v_count
  FROM t_table
  WHERE tableno = i_orignaltableno;
  IF v_count = 1 THEN
    SELECT
      COUNT(1) INTO v_count
    FROM t_table
    WHERE tableno = i_targettableno
    AND status = '0';
    IF v_count = 1 THEN
      SELECT
        status,
        orderid,
        tableid INTO v_status, v_orderid, v_table_orginal_id
      FROM t_table
      WHERE tableno = i_orignaltableno;

      SELECT
        tableid,
        orderid INTO v_tableid, v_t_orderid
      FROM t_table
      WHERE tableno = i_targettableno;

      IF v_status = 0 THEN
        SET v_status = 1;
      END IF;

     


      
      UPDATE t_table
      SET orderid = NULL,
          status = 0
      WHERE orderid = v_orderid;



      
      UPDATE t_table
      SET orderid = v_orderid,
          status = v_status
      WHERE tableNo = i_targettableno;

      UPDATE t_order
      SET currenttableid = v_tableid,
          relateorderid = NULL,
          payway = NULL
      WHERE orderid = v_orderid;


     SELECT
        CONCAT('台号:', ' ', IFNULL(tableno, '')) INTO v_tableno
      FROM t_tablearea ta,
           t_table tb
      WHERE tb.areaid = ta.areaid
      AND tb.tableid = v_tableid;

        
     UPDATE t_printobj tp
      SET tp.tableno = v_tableno,
          tp.tableid = v_tableid
      where tp.orderno =   v_orderid ;



    
      SET o_result = '0';
    ELSE
      SET o_result = '1';
    END IF;
  ELSE
    SET o_result = '1';
  END IF;


END
$$

--
-- Definition for procedure p_syndata
--

DROP PROCEDURE IF EXISTS `p_syndata`$$
DELIMITER ;;
CREATE PROCEDURE `p_syndata`(IN i_branch_id varchar(50), INOUT i_result varchar(500))
    SQL SECURITY INVOKER
BEGIN
  
  DECLARE done int DEFAULT 0;
  DECLARE v_id varchar(50);
  DECLARE v_branchid varchar(50);
  DECLARE v_sqltext longtext;
  DECLARE v_inserttime datetime;
  DECLARE v_status int;
  DECLARE v_generatetime datetime;
  DECLARE v_insert_str varchar(50);
  DECLARE v_orderSeqno integer;
  DECLARE v_error boolean DEFAULT FALSE;
  
  DECLARE cur_order CURSOR FOR
  SELECT
    id,
    branchid,
    sqltext,
    inserttime,
    status,
    generattime,
    orderSeqno
  FROM t_syn_sql t
  WHERE t.status = '0' 
  AND t.sqltext IS NOT NULL AND t.sqltext <> ''
  ORDER BY orderseqno, generattime;

  DROP TEMPORARY TABLE IF EXISTS t_temp_syn_sqlid;
  CREATE TEMPORARY TABLE t_temp_syn_sqlid
    (
      id VARCHAR(50) NOT NULL
    ) ENGINE = MEMORY DEFAULT CHARSET = utf8;
	
	DROP TEMPORARY TABLE IF EXISTS t_temp_syn_delid;
  CREATE TEMPORARY TABLE t_temp_syn_delid
    (
      id VARCHAR(50) NOT NULL
    ) ENGINE = MEMORY DEFAULT CHARSET = utf8;
	
  BEGIN
  
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    #sql执行错误继续运行
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  SET v_error = TRUE;

    OPEN cur_order;
  
    REPEAT
  
      FETCH cur_order INTO v_id, v_branchid, v_sqltext, v_inserttime, v_status, v_generatetime, v_orderSeqno;

      IF done <> 1 AND v_error = FALSE  THEN
        SET v_insert_str = UPPER(SUBSTRING(TRIM(v_sqltext), 1, 6));
        IF v_insert_str = 'INSERT' THEN
          SET v_sqltext = CONCAT('INSERT IGNORE ', SUBSTRING(TRIM(v_sqltext), 7));
        END IF;
        SET @sqlstr = v_sqltext;
        PREPARE v_sql FROM @sqlstr;
        EXECUTE v_sql;
        DEALLOCATE PREPARE v_sql;
      END IF;
	  
	  INSERT INTO t_temp_syn_delid (id) VALUES (v_id);
	  
      IF  v_error = TRUE THEN
		SET v_error = FALSE;
	  ELSE
		INSERT INTO t_temp_syn_sqlid (id) VALUES (v_id);
      END  IF;

    UNTIL done = 1

    END REPEAT;

	CLOSE cur_order;
  END;
  
  #根据条件删除临时表数据，防止刚下发的数据被误删除
  DELETE FROM t_syn_sql_temp  using  t_temp_syn_delid ,t_syn_sql_temp  WHERE  t_temp_syn_delid.id = t_syn_sql_temp.id;

  #只更新成功执行sql的数据状态
  UPDATE t_syn_sql a,t_temp_syn_sqlid b SET a.STATUS = '1' WHERE a.id = b.id; 
	
  SET i_result = '1';

END
;;
DELIMITER $$

--
-- Definition for procedure p_update2vipprice
--
DROP PROCEDURE IF EXISTS p_update2vipprice$$
CREATE PROCEDURE p_update2vipprice(IN i_orderid varchar(50))
  SQL SECURITY INVOKER
BEGIN
 
 
 DECLARE done int DEFAULT 0;
 DECLARE v_orderprice decimal;
 DECLARE v_orignalprice decimal;
 DECLARE v_vipprice  decimal;
 DECLARE v_dishid  varchar(50);
 DECLARE v_dishunit varchar(50);

 declare v_menuid  varchar(50);
 

DECLARE cur_order CURSOR FOR

  SELECT t.orderprice,t.orignalprice,t.dishid,t.dishunit
    FROM t_order_detail t
  WHERE t.orderid =  i_orderid AND dishid !='DISHES_98' AND orderprice > 0;

 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
 
OPEN cur_order;

 
REPEAT

     
IF done <> 1 THEN

      
select menuid into v_menuid   from v_currmenu;
 
select DISTINCT vipprice INTO   v_vipprice from t_template_dishunit 
        where menuid  = v_menuid and unit =v_dishunit  and dishid = v_dishid;
 
UPDATE t_order_detail 
        set orderprice = v_vipprice
      WHERE dishid = v_dishid AND dishunit = v_dishunit
      AND  ORDERid = i_orderid;
 
       
   END IF;

  UNTIL done = 1
  END REPEAT;

 
CLOSE cur_order;

 
END
$$

--
-- Definition for procedure p_orderdatas_cleanup
--
DROP PROCEDURE IF EXISTS p_orderdatas_cleanup$$
CREATE DEFINER=`root`@`%` PROCEDURE `p_orderdatas_cleanup`(IN  pi_branchid INT(11), 
                                                IN  pi_type     SMALLINT, 
                                                IN  pi_orderid  VARCHAR(5000), 
                                                IN  pi_ksrq     DATETIME, 
                                                IN  pi_jsrq     DATETIME, 
                                                OUT po_errmsg   VARCHAR(500)
                                                
)
    SQL SECURITY INVOKER
    COMMENT '按时间或订单编号清理订单数据'
label_main:
BEGIN
  
  
  declare v_result VARCHAR(500) DEFAULT '';


  
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1 v_result = MESSAGE_TEXT;
    set po_errmsg = concat('清理失败！原因：',v_result);
    ROLLBACK;
  END;


  IF pi_branchid IS NULL THEN
    SET po_errmsg = '清理失败！原因：分店ID输入不能为空';
    LEAVE label_main;
  END IF;

  IF pi_type != 0 AND pi_type != 1 THEN
    SET po_errmsg = '清理失败！原因：请按照指定值填写清理方式：0：按订单编号清理，1：按时间清理';
    LEAVE label_main;
  END IF;

  IF pi_type = 0 AND pi_orderid IS NULL THEN
    SET po_errmsg = '清理失败！原因：你选择的是按订单编号清理，请输入订单编号';
    LEAVE label_main;
  END IF;

  IF pi_type = 1 AND (pi_ksrq IS NULL OR pi_jsrq IS NULL) THEN
    SET po_errmsg = '清理失败！原因：你选择的是按时间清理，请正确输入开始结束时间';
    LEAVE label_main;
  END IF;

  
  SET @@max_heap_table_size = 1024 * 1024 * 300;
  SET @@tmp_table_size = 1024 * 1024 * 300;

  
  DROP TEMPORARY TABLE IF EXISTS t_temp_order;
  CREATE TEMPORARY TABLE t_temp_order
  (
    orderid VARCHAR(50)
  ) ENGINE = MEMORY DEFAULT CHARSET = utf8;

  IF pi_type = 0 THEN
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order
    WHERE
      branchid = pi_branchid
      AND find_in_set(orderid, pi_orderid);
  ELSE
    INSERT INTO t_temp_order
    SELECT orderid
    FROM
      t_order
    WHERE
      branchid = pi_branchid
      AND begintime BETWEEN pi_ksrq AND pi_jsrq;
  END IF;

  

  
  START TRANSACTION; 
  delete from t_order where orderid in (SELECT orderid from t_temp_order);
  set po_errmsg =concat('t_order：' , ROW_COUNT());

  delete from t_order_detail where orderid in (SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_order_detail：' , ROW_COUNT());

  delete from t_order_detail_discard where orderid in (SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_order_detail_discard：' , ROW_COUNT());

  
  delete from t_settlement where orderid in (SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_settlement：' , ROW_COUNT());

  delete from t_settlement_history where orderid in (SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_settlement_history：' , ROW_COUNT());

  delete from t_settlement_detail_history where orderid in (SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_settlement_detail_history：' , ROW_COUNT());

  delete from t_order_member where orderid in (SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_order_member：' , ROW_COUNT());

  delete from t_settlement_detail where orderid in (SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_settlement_detail：' , ROW_COUNT());

  
  delete from t_printdish where printobjid in (SELECT distinct a.id from t_printobj a, t_temp_order b where a.orderno = b.orderid);
  delete from t_printobj where orderno in (SELECT orderid from t_temp_order);

  
  delete from t_gift_log where order_id in (SELECT orderid from t_temp_order);

  
  delete from t_invoice where orderid in (SELECT orderid from t_temp_order);

  update t_table set orderid=null ,status='0' where orderid in(SELECT orderid from t_temp_order);
  SET po_errmsg = concat(po_errmsg , ' t_table：' , ROW_COUNT());

  if pi_type = 1 then
    DELETE FROM t_open_log;
    delete FROM t_open_log;
    DELETE FROM t_branch_biz_log;  
    update t_printer SET printnum = 0;
  
    
    UPDATE sequence SET val = 1 WHERE name = 'one';
  end if;

  commit;

  SET po_errmsg = concat('清理成功！\n', po_errmsg);
END
$$

--
-- Definition for function fristPinyin
--
DROP FUNCTION IF EXISTS fristPinyin$$
CREATE FUNCTION fristPinyin(P_NAME VARCHAR(255))
  RETURNS varchar(255) CHARSET utf8
  SQL SECURITY INVOKER
BEGIN

    DECLARE V_RETURN VARCHAR(255);

    SET V_RETURN = ELT(INTERVAL(CONV(HEX(left(CONVERT(P_NAME USING gbk),1)),16,10), 

        0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7, 

        0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,

        0xC8F6,0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),    

    'A','B','C','D','E','F','G','H','J','K','L','M','N','O','P','Q','R','S','T','W','X','Y','Z');

    RETURN V_RETURN;

END
$$

--
-- Definition for function f_cal_dish_count
--
DROP FUNCTION IF EXISTS f_cal_dish_count$$
CREATE FUNCTION f_cal_dish_count(i_coupondetailid varchar(100), i_orderid varchar(50))
  RETURNS int(11)
  SQL SECURITY INVOKER
BEGIN
  DECLARE v_count int;
  SELECT
    COUNT(1) INTO v_count
  FROM t_order_detail tod
  WHERE tod.orderid = i_orderid
  AND tod.debitamount != NULL
  AND tod.debitamount > 0
  AND FIND_IN_SET(tod.dishid, (SELECT
      dishid
    FROM t_dish_cal_factor_temp tdcft
    WHERE tdcft.coupondetailid = i_coupondetailid));

  RETURN v_count;
END
$$

--
-- Definition for function getPY
--
DROP FUNCTION IF EXISTS getPY$$
CREATE FUNCTION getPY(in_string VARCHAR(1000))
  RETURNS text CHARSET utf8
  SQL SECURITY INVOKER
BEGIN

DECLARE tmp_str VARCHAR(1000) charset utf8 DEFAULT '' ; 

DECLARE tmp_len SMALLINT DEFAULT 0;

DECLARE tmp_char VARCHAR(2) charset gbk DEFAULT '';

DECLARE tmp_rs VARCHAR(1000) charset gbk DEFAULT '';

DECLARE tmp_cc VARCHAR(2) charset gbk DEFAULT '';

SET tmp_str = in_string;

SET tmp_len = LENGTH(tmp_str);

WHILE tmp_len > 0 DO 

SET tmp_char = LEFT(tmp_str,1);

SET tmp_cc = tmp_char;

IF LENGTH(tmp_char)>1 THEN

SELECT ELT(INTERVAL(CONV(HEX(tmp_char),16,10),0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,0xBFA6,0xC0AC 

,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,0xCBFA,0xCDDA ,0xCEF4,0xD1B9,0xD4D1), 

'A','B','C','D','E','F','G','H','J','K','L','M','N','O','P','Q','R','S','T','W','X','Y','Z') INTO tmp_cc; 

END IF; 

SET tmp_rs = CONCAT(tmp_rs,tmp_cc);

SET tmp_str = SUBSTRING(tmp_str,2);

SET tmp_len = LENGTH(tmp_str);

END WHILE; 

IF ISNULL(tmp_rs) THEN
RETURN '';
ELSE
RETURN tmp_rs;
END IF;

END
$$

--
-- Definition for function getseqno
--
DROP FUNCTION IF EXISTS getseqno$$
CREATE FUNCTION getseqno(seq_name varchar(20))
  RETURNS varchar(100) CHARSET utf8
  SQL SECURITY INVOKER
BEGIN

  DECLARE valuestr varchar(200);

  DECLARE maxvalues int;

  DECLARE v_branchid varchar(10);

  DECLARE v_current_date varchar(20);

  DECLARE v_max_order_id varchar(30);

  DECLARE v_order_id_suffix varchar(10);

  DECLARE v_order_id_seq varchar(30);

  DECLARE v_count_order int;



  SET v_current_date = DATE_FORMAT(NOW(), '%Y%m%d');
  SELECT
    LPAD(branchid, 6, '0') INTO v_branchid
  FROM t_branch_info;

  SELECT
    COUNT(1) INTO v_count_order
  FROM t_order
  WHERE orderid LIKE '%' || CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid) || '%';

  IF v_count_order > 0 THEN
    SELECT
      MAX(orderid) INTO v_max_order_id
    FROM t_order
    WHERE orderid LIKE '%' || CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid) || '%';
	-- 如果是子订单，需要截取
	IF LOCATE('-', v_max_order_id) > 0 THEN
		SELECT substring_index(v_max_order_id, '-', 1) INTO v_max_order_id FROM dual;
		SELECT
			RIGHT(v_max_order_id, 6) INTO v_max_order_id
		FROM dual;
	ELSE
		SELECT
			RIGHT(v_max_order_id, 6) INTO v_max_order_id
		FROM dual;
	END IF;

    SELECT
      v_max_order_id + 1 INTO v_order_id_seq
    FROM dual;
    UPDATE sequence
    SET val = CAST(v_order_id_seq AS SIGNED)
    WHERE name = seq_name;
    SET valuestr = CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid, LPAD(v_order_id_seq, 6, '0'));
  ELSE

    SELECT
      MAX(val) INTO maxvalues
    FROM sequence
    WHERE name = seq_name;
    SELECT
      LPAD(maxvalues + 1, 6, '0') INTO valuestr;
    UPDATE sequence
    SET val = maxvalues + 1
    WHERE name = seq_name;
    SET valuestr = CONCAT('H', DATE_FORMAT(NOW(), '%Y%m%d'), v_branchid, valuestr);
  END IF;

  RETURN valuestr;

END
$$

--
-- Definition for function tableseqno
--
DROP FUNCTION IF EXISTS tableseqno$$
CREATE FUNCTION tableseqno(seq_name char (20))
  RETURNS int(11)
  SQL SECURITY INVOKER
begin 

 UPDATE tableseqno SET val=last_insert_id(val+1) WHERE name=seq_name; 

 RETURN last_insert_id(); 

end
$$

--
-- Definition for event event1
--
DROP EVENT IF EXISTS event1$$
CREATE 
EVENT event1
	ON SCHEDULE EVERY '3' MINUTE
	STARTS '2015-08-04 17:53:28'
	ON COMPLETION PRESERVE
	DO 
BEGIN
  declare branchcount int; 
  declare v_branchid int;
  declare v_menuid varchar(50);
  select count(1) into branchcount from t_branch_info;
  if branchcount>0 then
    select branchid into v_branchid from t_branch_info;
    update t_menu tm SET tm.status='1' WHERE tm.status='2' AND tm.effecttime<=NOW() and tm.menuid IN (SELECT tmb.menuid FROM t_menu_branch tmb WHERE tmb.branchid=v_branchid);
    select menuid into v_menuid from v_currmenu;
    update t_menu set status='4' where status='1' and menuid!=v_menuid and menuid IN (SELECT tmb.menuid FROM t_menu_branch tmb WHERE tmb.branchid=v_branchid);
  else
    UPDATE t_menu tm SET tm.status='1' WHERE tm.status='2' AND tm.effecttime<=NOW();
    end if;
END
$$

DROP PROCEDURE IF EXISTS p_update_primarykey$$
CREATE PROCEDURE p_update_primarykey(in primarykey varchar(100))
COMMENT '更新重复的primarykey'

BEGIN

DECLARE done int DEFAULT 0;

DECLARE v_detail_id varchar(100);

DECLARE  temp_uuid varchar(100);

DECLARE cur_detailids CURSOR FOR SELECT orderdetailid from t_order_detail d where  d.primarykey=primarykey;

DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  OPEN cur_detailids;
  REPEAT
    FETCH cur_detailids INTO v_detail_id;
				IF done <> 1 THEN
								SELECT  UUID() into temp_uuid;
								UPDATE t_order_detail set primarykey=temp_uuid where orderdetailid=v_detail_id;
				 END IF;
     UNTIL done = 1
  END REPEAT;

END
$$

DROP PROCEDURE IF EXISTS p_get_primarykeys$$
CREATE PROCEDURE p_get_primarykeys()
COMMENT '获取重复的primarykey'

BEGIN
DECLARE done int DEFAULT 0;
DECLARE  v_total varchar(100);
DECLARE  v_primarykey varchar(100);

-- ###定义一个游标表示所有重复的primarykey
DECLARE cur_repat_keys CURSOR FOR SELECT count(1) total,t.primarykey
			                          from t_order_detail t
	                                   GROUP BY t.primarykey
					                    HAVING total>1
			                          ORDER BY total desc;
-- ##先更新以前没有用到primarykey字段的数据
update t_order_detail set primarykey=UUID() where primarykey='';
OPEN cur_repat_keys;
  REPEAT
    FETCH cur_repat_keys INTO v_total,v_primarykey;
				IF done <> 1 THEN
				call p_update_primarykey(v_primarykey);
				END IF;
  UNTIL done = 1
  END REPEAT;

END
$$

DROP PROCEDURE IF EXISTS p_check_source_data$$
CREATE PROCEDURE p_check_source_data(IN pi_branchid  INT,
                                              IN pi_begintime DATETIME,
                                              IN pi_endtime   DATETIME
                                              )
  SQL SECURITY INVOKER
  COMMENT '生成JDE数据前,对原始数据的校验：
    检查项1：结算方式汇总额（每单） = 品项销售汇总额（每单）'
BEGIN
  DECLARE v_row_count       INT;
  DECLARE v_fetch_times     INT DEFAULT 0;
  DECLARE v_orderid         VARCHAR(50);
  DECLARE v_debitamount_all NUMERIC(8, 2);
  DECLARE cur_order CURSOR FOR SELECT orderid
                               FROM
                                 t_temp_order_check t;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1 @error = MESSAGE_TEXT;
    SELECT 0 AS returnvalue
         , concat('校验异常:', v_orderid, @error) AS errorinfo;
  END;

  #创建订单临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_check;
  CREATE TEMPORARY TABLE t_temp_order_check
  (
    orderid VARCHAR(50)
  ) ENGINE = HEAP DEFAULT CHARSET = utf8;
  INSERT INTO t_temp_order_check
  SELECT orderid
  FROM
    t_order t
  WHERE
    t.begintime BETWEEN pi_begintime AND pi_endtime
    AND t.orderstatus = 3
    AND t.branchid = pi_branchid;

  SELECT count(1)
  INTO
    v_row_count
  FROM
    t_temp_order_check; #获取订单数量

  #创建订单详情临时内存表
  DROP TEMPORARY TABLE IF EXISTS t_temp_order_detail_check;
  CREATE TEMPORARY TABLE t_temp_order_detail_check
  (
    orderid VARCHAR(50),
    dishid VARCHAR(50),
    dishtype INT,
    dishunit VARCHAR(100),
    superkey VARCHAR(255),
    primarykey VARCHAR(255),
    debitamount DECIMAL(20, 2)
  ) ENGINE = HEAP DEFAULT CHARSET = utf8;
  INSERT INTO t_temp_order_detail_check
  SELECT t.orderid
       , t.dishid
       , t.dishtype
       , t.dishunit
       , t.superkey
       , t.primarykey
       , t.debitamount
  FROM
    t_order_detail t, t_temp_order_check b
  WHERE
    t.orderid = b.orderid;

  
  OPEN cur_order;
  WHILE v_fetch_times < v_row_count
  DO
    FETCH cur_order INTO v_orderid;
    SET v_fetch_times = v_fetch_times + 1;

    SELECT ifnull(sum(a.debitamount),0)
    INTO
      v_debitamount_all
    FROM
      t_temp_order_detail_check a
    WHERE
      a.orderid = v_orderid;

    IF v_debitamount_all = 0 THEN
      CALL p_cal_dish_debit_amount(v_orderid,@a,@b);
    END IF;

  END WHILE;
  CLOSE cur_order;

END
$$

